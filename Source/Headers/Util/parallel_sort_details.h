#ifndef SGM_INTERNAL_SORTIMPLEMENTATION_H
#define SGM_INTERNAL_SORTIMPLEMENTATION_H

///////////////////////////////////////////////////////////////////////////////
//
// PARALLEL SORT IMPLEMENTATION
//
///////////////////////////////////////////////////////////////////////////////

// This file contains code derived and modified with permission from the
// original sort_parallel library (https://github.com/fjtapia/sort_parallel).
//
// Copyright (c) 2016 Francisco Jose Tapia (fjtapia@gmail.com)
// Distributed under the Boost Software License, Version 1.0.
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <algorithm>
#include <atomic>
#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <functional>
#include <future>
#include <iterator>
#include <memory>
#include <stdexcept>
#include <type_traits>
#include <utility>
#include <vector>

#if !defined( _MSC_VER ) || _MSC_VER >= 1900
#define NOEXCEPT noexcept
#define NOEXCEPT_ARGS(ARGS) noexcept((ARGS))
#else
#define NOEXCEPT
#define NOEXCEPT_ARGS(ARGS)
#endif

// This value is the minimal number of threads for to use the
// block_indirect_sort algorithm
#define SGM_BLOCK_INDIRECT_NTHREAD_BORDER 6

namespace SGMInternal
{
namespace detail
{

///////////////////////////////////////////////////////////////////////////////
//
// UTILITY NAMESPACE
//
// Lower level structures and functions for sort implementation.
//
///////////////////////////////////////////////////////////////////////////////

namespace util
{

///////////////////////////////////////////////////////////////////////////////
//
// Atomic variable using a memory model.
//
///////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T atomic_read(std::atomic<T> &at_var)
    {
    return std::atomic_load_explicit<T>(&at_var, std::memory_order_acquire);
    }

/// Add a number to an atomic variable, using a memory model
template <typename T, typename T2>
inline T atomic_add(std::atomic<T> &at_var, T2 num)
    {
    static_assert(std::is_integral<T2>::value, "Bad parameter");
    return std::atomic_fetch_add_explicit<T>(&at_var, (T) num, std::memory_order_acq_rel);
    }

/// Subtract from an atomic variable using memory model
template <typename T, typename T2>
inline T atomic_sub(std::atomic<T> &at_var, T2 num)
    {
    static_assert(std::is_integral<T2>::value, "Bad parameter");
    return std::atomic_fetch_sub_explicit<T>(&at_var, (T) num,
                                             std::memory_order_acq_rel);
    }

/// Write a value in an atomic variable using memory model
template <typename T, typename T2>
inline void atomic_write(std::atomic<T> &at_var, T2 num)
    {
    static_assert(std::is_integral<T2>::value, "Bad parameter");
    std::atomic_store_explicit<T>(&at_var, (T) num, std::memory_order_release);
    }

///////////////////////////////////////////////////////////////////////////////
//
// Metaprogramming compare_iter and enable_if_not_integral
//
///////////////////////////////////////////////////////////////////////////////

/// From the iterator, received as template parameter, obtain the type
/// of the object pointed by the iterator, and with this define the
/// std::less with this type obtained, simplifying the default template parameter of comparison.
template <class iter_t>
using compare_iter = std::less<typename std::iterator_traits<iter_t>::value_type>;

/// From the iterator, obtain the type pointed by it,
/// simplifying the default template parameter of comparison.
template <class iter_t>
using value_iter = typename std::iterator_traits<iter_t>::value_type;

/// A SFINAE class to detect if the third parameter in the invocation of the parallel sorting algorithms is an integer
/// representing the number of threads to use or is a comparison object.
template <class T>
using enable_if_not_integral = typename std::enable_if<!std::is_integral<T>::value>::type;

/// A SFINAE class to detect if the parameter is a std::string for to apply specialized parameters in the invocation
/// of the block_indirect_sort algorithm
template <class T>
using enable_if_string = typename std::enable_if<std::is_same<T, std::string>::value>::type;

/// A SFINAE class to detect if the parameter is a std::string for to apply specialized parameters in the invocation
/// of the block_indirect_sort algorithm
template <class T>
using enable_if_not_string = typename std::enable_if<!std::is_same<T, std::string>::value>::type;

///////////////////////////////////////////////////////////////////////////////
//
// Low level functions to in-place create, destroy, move and merge.
//
///////////////////////////////////////////////////////////////////////////////

/// create an object in the memory specified by ptr
///
/// @param ptr : pointer to the memory where to create the object
/// @param args : arguments to the constructor
template <class Value_t, class... Args>
inline void construct(Value_t *ptr, Args &&... args)
    {
    (::new(static_cast<void *> (ptr))
        Value_t(std::forward<Args>(args)...));
    }

/// destroy an object in the memory specified by ptr
/// @param ptr : pointer to the object to destroy
template <class Value_t>
inline void destroy_object(Value_t *ptr)
    {
    ptr->~Value_t();
    }

/// initialize a range of objects with the object val moving across them
///
/// @param first : iterator to the first element to initialize
/// @param last : iterator to the last element to initialize
/// @param val : object used for the initialization
template <class Iter_t>
void init(Iter_t first, Iter_t last, typename std::iterator_traits<Iter_t>::value_type &val)
    {
    if (first == last) return;
    construct(&(*first), std::move(val));

    Iter_t it1 = first, it2 = first + 1;
    while (it2 != last)
        {
        construct(&(*(it2++)), std::move(*(it1++)));
        };
    val = std::move(*(last - 1));
    }

/// Move initialized objects
/// @param it_dest : iterator to the final place of the objects
/// @param first : iterator to the first element to move
/// @param last : iterator to the last element to move
template <class Iter1_t, class Iter2_t>
Iter2_t init_move(Iter2_t it_dest, Iter1_t first, Iter1_t last)
    {
    while (first != last) *(it_dest++) = std::move(*(first++));
    return it_dest;
    }

/// Move objects to uninitialized memory
///
/// @param ptr : pointer to the memory where to create the objects
/// @param first : iterator to the first element to move
/// @param last : iterator to the last element to move
template <class Iter_t, class Value_t = typename std::iterator_traits<Iter_t>::value_type>
Value_t *uninit_move(Value_t *ptr, Iter_t first, Iter_t last)
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value2_t;
    static_assert(std::is_same<Value_t, value2_t>::value, "Incompatible iterators\n");
    while (first != last)
        {
        ::new(static_cast<void *> (ptr++)) Value_t(std::move(*(first++)));
        };
    return ptr;
    }

/// destroy the elements between first and last
/// @param first : iterator to the first element to destroy
/// @param last : iterator to the last element to destroy
template <class Iter_t>
void destroy(Iter_t first, const Iter_t last)
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;
    while (first != last)
        {
        (&(*(first++)))->~value_t();
        };
    }

/// Merge two contiguous buffers pointed by buf1 and buf2, and put
///        in the buffer pointed by buf_out
///
/// @param buf1 : iterator to the first element in the first buffer
/// @param end_buf1 : final iterator of first buffer
/// @param buf2 : iterator to the first iterator to the second buffer
/// @param end_buf2 : final iterator of the second buffer
/// @param buf_out : buffer where move the elements merged
/// @param comp : comparison object
template <class Iter1_t, class Iter2_t, class Compare>
Iter2_t full_merge(Iter1_t buf1, const Iter1_t end_buf1, Iter1_t buf2,
                   const Iter1_t end_buf2, Iter2_t buf_out, Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type value1_t;
    typedef typename std::iterator_traits<Iter2_t>::value_type value2_t;
    static_assert(std::is_same<value1_t, value2_t>::value, "Incompatible iterators\n");
    while ((buf1 != end_buf1) and (buf2 != end_buf2))
        {
        *(buf_out++) = (not comp(*buf2, *buf1)) ? std::move(*(buf1++))
                                                : std::move(*(buf2++));
        };
    return (buf1 == end_buf1) ? init_move(buf_out, buf2, end_buf2)
                              : init_move(buf_out, buf1, end_buf1);
    }

/// Merge two contiguous buffers pointed by first1 and first2, and put
///        in the uninitialized buffer pointed by it_out
///
/// @param first1 : iterator to the first element in the first buffer
/// @param last1 : last iterator of the first buffer
/// @param first2 : iterator to the first element to the second buffer
/// @param last2 : final iterator of the second buffer
/// @param it_out : uninitialized buffer where move the elements merged
/// @param comp : comparison object
template <class Iter_t, class Value_t, class Compare>
Value_t *uninit_full_merge(Iter_t first1, const Iter_t last1, Iter_t first2,
                           const Iter_t last2, Value_t *it_out, Compare comp)
    {
    typedef typename std::iterator_traits<Iter_t>::value_type type1;
    static_assert(std::is_same<Value_t, type1>::value, "Incompatible iterators\n");
    while (first1 != last1 and first2 != last2)
        {
        construct((it_out++), (not comp(*first2, *first1))
                              ? std::move(*(first1++))
                              : std::move(*(first2++)));
        };
    return (first1 == last1) ? uninit_move(it_out, first2, last2)
                             : uninit_move(it_out, first1, last1);
    }

/// Merge two buffers. The first buffer is in a separate memory.
///          The second buffer have a empty space before buf2 of the same size
///          than the (end_buf1 - buf1)
///
/// @param buf1 : iterator to the first element of the first buffer
/// @param end_buf1 : iterator to the last element of the first buffer
/// @param buf2 : iterator to the first element of the second buffer
/// @param end_buf2 : iterator to the last element of the second buffer
/// @param buf_out : iterator to the first element to the buffer where put
///                  the result
/// @param comp : object for Compare two elements of the type pointed
///                by the Iter1_t and Iter2_t
template <class Iter1_t, class Iter2_t, class Compare>
Iter2_t half_merge(Iter1_t buf1, const Iter1_t end_buf1, Iter2_t buf2,
                   const Iter2_t end_buf2, Iter2_t buf_out, Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type value1_t;
    typedef typename std::iterator_traits<Iter2_t>::value_type value2_t;
    static_assert(std::is_same<value1_t, value2_t>::value, "Incompatible iterators\n");

    while ((buf1 != end_buf1) and (buf2 != end_buf2))
        {
        *(buf_out++) = (not comp(*buf2, *buf1)) ? std::move(*(buf1++))
                                                : std::move(*(buf2++));
        };
    return (buf2 == end_buf2) ? init_move(buf_out, buf1, end_buf1) : end_buf2;
    }

/// merge two uncontiguous buffers, placing the results in the buffers
///          Use an auxiliary buffer pointed by aux
///
/// @param src1 : iterator to the first element of the first buffer
/// @param end_src1 : last iterator  of the first buffer
/// @param src2 : iterator to the first element of the second buffer
/// @param end_src2 : last iterator  of the second buffer
/// @param aux  : iterator to the first element of the auxiliary buffer
/// @param comp : object for to Compare elements
/// @return true : not changes done,  false : changes in the buffers
template <class Iter1_t, class Iter2_t, class Iter3_t, class Compare>
bool in_place_merge_uncontiguous(Iter1_t src1, const Iter1_t end_src1,
                                 Iter2_t src2, const Iter2_t end_src2,
                                 Iter3_t aux, Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    typedef typename std::iterator_traits<Iter3_t>::value_type type3;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");
    static_assert(std::is_same<type3, type2>::value, "Incompatible iterators\n");

    if (src1 == end_src1 or src2 == end_src2 or
        not comp(*src2, *(end_src1 - 1)))
        return true;

    while (src1 != end_src1 and not comp(*src2, *src1)) ++src1;

    Iter3_t const end_aux = aux + (end_src1 - src1);
    Iter2_t src2_first = src2;
    init_move(aux, src1, end_src1);

    while ((src1 != end_src1) and (src2 != end_src2))
        {
        *(src1++) = std::move((not comp(*src2, *aux)) ? *(aux++) : *(src2++));
        }

    if (src2 == end_src2)
        {
        while (src1 != end_src1) *(src1++) = std::move(*(aux++));
        init_move(src2_first, aux, end_aux);
        }
    else
        {
        half_merge(aux, end_aux, src2, end_src2, src2_first, comp);
        };
    return false;
    }

/// merge two contiguous buffers,using an auxiliary buffer pointed
///          by buf. The results are in src1 and src2
///
/// @param src1: iterator to the first position of the first buffer
/// @param src2: final iterator of the first buffer and first iterator
///              of the second buffer
/// @param end_src2 : final iterator of the second buffer
/// @param buf  : iterator to buffer used as auxiliary memory
/// @param comp : object for to Compare elements
/// @return true : not changes done,  false : changes in the buffers
template <class Iter1_t, class Iter2_t, class Compare>
bool in_place_merge(Iter1_t src1, Iter1_t src2, Iter1_t end_src2, Iter2_t buf,
                    Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    if (src1 == src2 or src2 == end_src2 or not comp(*src2, *(src2 - 1)))
        return true;

    Iter1_t end_src1 = src2;
    while (src1 != end_src1 and not comp(*src2, *src1)) ++src1;

    if (src1 == end_src1) return false;

    size_t nx = end_src1 - src1;
    init_move(buf, src1, end_src1);
    half_merge(buf, buf + nx, src2, end_src2, src1, comp);
    return false;
    }

///////////////////////////////////////////////////////////////////////////////
//
// A range [first, last), between iterators, and associated operations.
//
///////////////////////////////////////////////////////////////////////////////

/// @struct range
/// A range [first, last), between iterators, and associated operations.
template <class Iter_t>
struct range
    {
    Iter_t first, last;

    /// Empty constructor

    range() = default;

    /// Constructor with two parameters
    /// @param frs : iterator to the first element
    /// @param lst : iterator to the last element

    range(Iter_t frs, Iter_t lst) : first(frs), last(lst)
        {};

    /// indicate if the range is empty
    /// @return  true : empty false : not empty
    bool empty() const
        { return (first == last); };

    /// indicate if the range is not empty
    /// @return  true : not empty false : empty
    bool not_empty() const
        { return (first != last); };

    ///  Indicate if the range is well constructed, and valid
    /// @return true : valid,  false : not valid
    bool valid() const
        { return ((last - first) >= 0); };

    ///  return the size of the range
    /// @return size
    size_t size() const
        { return (last - first); };

    /// return an iterator to the first element of the range
    /// @return iterator
    Iter_t front() const
        { return first; };

    /// return an iterator to the last element of the range
    /// @return iterator
    Iter_t back() const
        { return (last - 1); };
    };

/// Concatenate two contiguous ranges
/// @param it1 : first range
/// @param it2 : second range
/// @return  range resulting of the concatenation
template <class Iter_t>
range<Iter_t> concat(const range<Iter_t> &it1, const range<Iter_t> &it2)
    {
    return range<Iter_t>(it1.first, it2.last);
    }

/// Move initialized objects from the range src to dest
/// @param dest : range where move the objects
/// @param src : range from where move the objects
/// @return range with the objects moved and the size adjusted
template <class Iter1_t, class Iter2_t>
inline range<Iter2_t> init_move(const range<Iter2_t> &dest,
                                const range<Iter1_t> &src)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    if (src.size() == 0)
        {
        return range<Iter2_t>(dest.first, dest.first);
        };
    init_move(dest.first, src.first, src.last);
    return range<Iter2_t>(dest.first, dest.first + src.size());
    }

/// Move uninitialized objects from the range src creating them in  dest
///
/// @param dest : range where move and create the objects
/// @param src : range from where move the objects
/// @return range with the objects moved and the size adjusted
template <class Iter1_t, class Iter2_t>
inline range<Iter2_t> uninit_move(const range<Iter2_t> &dest,
                                  const range<Iter1_t> &src)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    if (src.size() == 0)
        {
        return range<Iter2_t>(dest.first, dest.first);
        };
    uninit_move(dest.first, src.first, src.last);
    return range<Iter2_t>(dest.first, dest.first + src.size());
    }

/// Destroy a range of objects
/// @param rng : range to destroy
template <class Iter_t>
inline void destroy(range<Iter_t> rng)
    {
    destroy(rng.first, rng.last);
    }

/// Initialize a range of objects with the object val moving across them
/// @param rng : range of elements not initialized
/// @param val : object used for the initialization
/// @return range initialized
template <class Iter_t>
inline range<Iter_t>
init(const range<Iter_t> &rng,
     typename std::iterator_traits<Iter_t>::value_type &val)
    {
    init(rng.first, rng.last, val);
    return rng;
    }

/// Indicate if two ranges have a possible merge
/// @param src1 : first range
/// @param src2 : second range
/// @param comp : object for to compare elements
/// @return true : they can be merged
///         false : they can't be merged
template <class Iter1_t, class Iter2_t, class Compare>
inline bool is_mergeable(const range<Iter1_t> &src1,
                         const range<Iter2_t> &src2, Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    return comp(*(src2.front()), *(src1.back()));
    }

/// Merge two contiguous ranges src1 and src2, and put the result in
///        the range dest, returning the range merged
///
/// @param dest : range where locate the elements merged. the size of dest
///               must be  greater or equal than the sum of the sizes of
///               src1 and src2
/// @param src1 : first range to merge
/// @param src2 : second range to merge
/// @param comp : comparison object
/// @return range with the elements merged and the size adjusted
template <class Iter1_t, class Iter2_t, class Iter3_t, class Compare>
inline range<Iter3_t> full_merge(const range<Iter3_t> &dest,
                                 const range<Iter1_t> &src1,
                                 const range<Iter2_t> &src2, Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    typedef typename std::iterator_traits<Iter3_t>::value_type type3;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");
    static_assert(std::is_same<type3, type2>::value, "Incompatible iterators\n");

    return range<Iter3_t>(dest.first,
                          full_merge(src1.first, src1.last, src2.first,
                                     src2.last, dest.first, comp));
    }

/// Merge two contiguous uninitialized ranges src1 and src2, and create
///        and move the result in the uninitialized range dest, returning the
///        range merged
//
/// @param dest : range where locate the elements merged. the size of dest
///               must be  greater or equal than the sum of the sizes of
///               src1 and src2. Initially is uninitialize memory
/// @param src1 : first range to merge
/// @param src2 : second range to merge
/// @param comp : comparison object
/// @return range with the elements merged and the size adjusted
template <class Iter1_t, class Iter2_t, class Value_t, class Compare>
inline range<Value_t *> uninit_full_merge(const range<Value_t *> &dest,
                                          const range<Iter1_t> &src1,
                                          const range<Iter2_t> &src2,
                                          Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");
    static_assert(std::is_same<Value_t, type2>::value, "Incompatible iterators\n");

    return range<Value_t *>(
        dest.first, uninit_full_merge(src1.first, src1.last, src2.first,
                                      src2.last, dest.first, comp));
    }

/// Merge two initialized buffers. The first buffer is in a separate
///          memory
//
/// @param dest : range where finish the two buffers merged
/// @param src1 : first range to merge in a separate memory
/// @param src2 : second range to merge, in the final part of the
///               range where deposit the final results
/// @param comp : object for compare two elements of the type pointed
///               by the Iter1_t and Iter2_t
/// @return : range with the two buffers merged
template <class Iter1_t, class Iter2_t, class Compare>
inline range<Iter2_t> half_merge(const range<Iter2_t> &dest,
                                 const range<Iter1_t> &src1,
                                 const range<Iter2_t> &src2, Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    return range<Iter2_t>(dest.first,
                          half_merge(src1.first, src1.last, src2.first,
                                     src2.last, dest.first, comp));
    }

/// Merge two non contiguous ranges src1, src2, using the range
///          aux as auxiliary memory. The results are in the original ranges
/// @param src1 : first range to merge
/// @param src2 : second range to merge
/// @param aux : auxiliary range used in the merge
/// @param comp : object for to compare elements
/// @return true : not changes done, false : changes in the buffers
template <class Iter1_t, class Iter2_t, class Iter3_t, class Compare>
inline bool in_place_merge_uncontiguous(const range<Iter1_t> &src1,
                                        const range<Iter2_t> &src2,
                                        const range<Iter3_t> &aux,
                                        Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    typedef typename std::iterator_traits<Iter3_t>::value_type type3;

    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");
    static_assert(std::is_same<type3, type2>::value, "Incompatible iterators\n");

    return in_place_merge_uncontiguous(src1.first, src1.last, src2.first,
                                       src2.last, aux.first, comp);
    }

/// Merge two contiguous ranges ( src1, src2) using buf as
///          auxiliary memory. The results are in the same ranges
/// @param src1 : first range to merge
/// @param src1 : second range to merge
/// @param buf : auxiliary memory used in the merge
/// @param comp : object for to compare elements
/// @return true : not changes done,   false : changes in the buffers
template <class Iter1_t, class Iter2_t, class Compare>
inline range<Iter1_t> in_place_merge(const range<Iter1_t> &src1, const range<Iter1_t> &src2,
                                     const range<Iter2_t> &buf, Compare comp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    in_place_merge(src1.first, src1.last, src2.last, buf.first, comp);
    return concat(src1, src2);
    }

/// Merge two ranges, as part of a merge the ranges in a list. This
///         function reduce the number of movements compared with inplace_merge
///         when you need to merge a sequence of ranges.
///         This function merge the ranges rbuf and rng2, and the results
///          are in rng1 and rbuf
/// @param rng1 : range where locate the first elements of the merge
/// @param rbuf : range which provide the first elements, and where store
///               the last results of the merge
/// @param rng2 : range which provide the last elements to merge
/// @param comp : object for to compare elements
/// @return true : not changes done,  false : changes in the buffers
template <class Iter1_t, class Iter2_t, class Compare>
void merge_flow(range<Iter1_t> rng1, range<Iter2_t> rbuf,
                range<Iter1_t> rng2, Compare cmp)
    {
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    range<Iter2_t> rbx(rbuf);
    range<Iter1_t> rx1(rng1), rx2(rng2);
    assert (rbx.size() == rx1.size() and rx1.size() == rx2.size());
    while (rx1.first != rx1.last)
        {
        *(rx1.first++) = (cmp(*rbx.first, *rx2.first))
                         ? std::move(*(rbx.first++))
                         : std::move(*(rx2.first++));
        };
    if (rx2.first == rx2.last) return;
    if (rbx.first == rbx.last)
        util::init_move(rbuf, rng2);
    else
        util::half_merge(rbuf, rx2, rbx, cmp);
    }

///////////////////////////////////////////////////////////////////////////////
//
// Functions to merge 4 buffers
//
///////////////////////////////////////////////////////////////////////////////

/// Compare the elements pointed by it1 and it2, and if they
///        are equal, compare their position, doing a stable comparison
///
/// @param it1 : iterator to the first element
/// @param pos1 : position of the object pointed by it1
/// @param it2 : iterator to the second element
/// @param pos2 : position of the element pointed by it2
/// @param comp : comparison object
/// @return result of the comparison
template <class Iter_t, class Compare = typename compare_iter<Iter_t>::value_type>
inline bool less_range(Iter_t it1, uint32_t pos1, Iter_t it2, uint32_t pos2,
                       Compare comp = Compare())
    {
    return (comp(*it1, *it2)) ? true : (pos2 < pos1) ? false
                                                     : not(comp(*it2, *it1));
    }

/// Merge four ranges
///
/// @param dest: range where move the elements merged. Their size must be
///              greater or equal than the sum of the sizes of the ranges
///              in vrange_input
/// @param vrange_input : array of ranges to merge
/// @param nrange_input : number of ranges in vrange_input
/// @param comp : comparison object
/// @return range with all the elements moved with the size adjusted
template <class Iter1_t, class Iter2_t, class Compare>
range<Iter1_t> full_merge4(const range<Iter1_t> &rdest,
                           range<Iter2_t> vrange_input[4],
                           uint32_t nrange_input, Compare comp)
    {
    typedef range<Iter1_t> range1_t;
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    size_t ndest = 0;
    uint32_t i = 0;
    while (i < nrange_input)
        {
        if (vrange_input[i].size() != 0)
            {
            ndest += vrange_input[i++].size();
            }
        else
            {
            for (uint32_t k = i + 1; k < nrange_input; ++k)
                {
                vrange_input[k - 1] = vrange_input[k];
                };
            --nrange_input;
            };
        };

    if (nrange_input == 0) return range1_t(rdest.first, rdest.first);
    if (nrange_input == 1) return init_move(rdest, vrange_input[0]);
    if (nrange_input == 2)
        {
        return full_merge(rdest, vrange_input[0], vrange_input[1], comp);
        };

    uint32_t pos[4] = {0, 1, 2, 3}, npos = nrange_input;

    if (less_range(vrange_input[pos[1]].first, pos[1],
                   vrange_input[pos[0]].first, pos[0], comp))
        {
        std::swap(pos[0], pos[1]);
        };
    if (npos == 4 and less_range(vrange_input[pos[3]].first, pos[3],
                                 vrange_input[pos[2]].first, pos[2], comp))
        {
        std::swap(pos[3], pos[2]);
        };
    if (less_range(vrange_input[pos[2]].first, pos[2],
                   vrange_input[pos[0]].first, pos[0], comp))
        {
        std::swap(pos[0], pos[2]);
        };
    if (npos == 4 and less_range(vrange_input[pos[3]].first, pos[3],
                                 vrange_input[pos[1]].first, pos[1], comp))
        {
        std::swap(pos[1], pos[3]);
        };
    if (less_range(vrange_input[pos[2]].first, pos[2],
                   vrange_input[pos[1]].first, pos[1], comp))
        {
        std::swap(pos[1], pos[2]);
        };

    Iter1_t it_dest = rdest.first;
    while (npos > 2)
        {
        *(it_dest++) = std::move(*(vrange_input[pos[0]].first++));
        if (vrange_input[pos[0]].size() == 0)
            {
            pos[0] = pos[1];
            pos[1] = pos[2];
            pos[2] = pos[3];
            --npos;
            }
        else
            {
            if (less_range(vrange_input[pos[1]].first, pos[1],
                           vrange_input[pos[0]].first, pos[0], comp))
                {
                std::swap(pos[0], pos[1]);
                if (less_range(vrange_input[pos[2]].first, pos[2],
                               vrange_input[pos[1]].first, pos[1], comp))
                    {
                    std::swap(pos[1], pos[2]);
                    if (npos == 4 and
                        less_range(vrange_input[pos[3]].first, pos[3],
                                   vrange_input[pos[2]].first, pos[2], comp))
                        {
                        std::swap(pos[2], pos[3]);
                        };
                    };
                };
            };
        };

    range1_t raux1(rdest.first, it_dest), raux2(it_dest, rdest.last);
    if (pos[0] < pos[1])
        {
        return concat(raux1, full_merge(raux2, vrange_input[pos[0]],
                                        vrange_input[pos[1]], comp));
        }
    else
        {
        return concat(raux1, full_merge(raux2, vrange_input[pos[1]],
                                        vrange_input[pos[0]], comp));
        };
    }

/// Merge four ranges and put the result in uninitialized memory
///
/// @param dest: range where create and move the elements merged. Their
///              size must be greater or equal than the sum of the sizes
///              of the ranges in the array R
/// @param vrange_input : array of ranges to merge
/// @param nrange_input : number of ranges in vrange_input
/// @param comp : comparison object
/// @return range with all the elements move with the size adjusted
template <class Value_t, class Iter_t, class Compare>
range<Value_t *> uninit_full_merge4(const range<Value_t *> &dest,
                                    range<Iter_t> vrange_input[4],
                                    uint32_t nrange_input, Compare comp)
    {
    typedef typename std::iterator_traits<Iter_t>::value_type type1;
    static_assert(std::is_same<type1, Value_t>::value, "Incompatible iterators\n");

    size_t ndest = 0;
    uint32_t i = 0;
    while (i < nrange_input)
        {
        if (vrange_input[i].size() != 0)
            {
            ndest += vrange_input[i++].size();
            }
        else
            {
            for (uint32_t k = i + 1; k < nrange_input; ++k)
                {
                vrange_input[k - 1] = vrange_input[k];
                };
            --nrange_input;
            };
        };
    if (nrange_input == 0) return range<Value_t *>(dest.first, dest.first);
    if (nrange_input == 1) return uninit_move(dest, vrange_input[0]);
    if (nrange_input == 2)
        {
        return uninit_full_merge(dest, vrange_input[0], vrange_input[1], comp);
        };

    uint32_t pos[4] = {0, 1, 2, 3}, npos = nrange_input;

    if (less_range(vrange_input[pos[1]].first, pos[1],
                   vrange_input[pos[0]].first, pos[0], comp))
        {
        std::swap(pos[0], pos[1]);
        };
    if (npos == 4 and less_range(vrange_input[pos[3]].first, pos[3],
                                 vrange_input[pos[2]].first, pos[2], comp))
        {
        std::swap(pos[3], pos[2]);
        };
    if (less_range(vrange_input[pos[2]].first, pos[2],
                   vrange_input[pos[0]].first, pos[0], comp))
        {
        std::swap(pos[0], pos[2]);
        };
    if (npos == 4 and less_range(vrange_input[pos[3]].first, pos[3],
                                 vrange_input[pos[1]].first, pos[1], comp))
        {
        std::swap(pos[1], pos[3]);
        };
    if (less_range(vrange_input[pos[2]].first, pos[2],
                   vrange_input[pos[1]].first, pos[1], comp))
        {
        std::swap(pos[1], pos[2]);
        };

    Value_t *it_dest = dest.first;
    while (npos > 2)
        {
        construct(&(*(it_dest++)),
                  std::move(*(vrange_input[pos[0]].first++)));
        if (vrange_input[pos[0]].size() == 0)
            {
            pos[0] = pos[1];
            pos[1] = pos[2];
            pos[2] = pos[3];
            --npos;
            }
        else
            {
            if (less_range(vrange_input[pos[1]].first, pos[1],
                           vrange_input[pos[0]].first, pos[0], comp))
                {
                std::swap(pos[0], pos[1]);
                if (less_range(vrange_input[pos[2]].first, pos[2],
                               vrange_input[pos[1]].first, pos[1], comp))
                    {
                    std::swap(pos[1], pos[2]);
                    if (npos == 4 and
                        less_range(vrange_input[pos[3]].first, pos[3],
                                   vrange_input[pos[2]].first, pos[2], comp))
                        {
                        std::swap(pos[2], pos[3]);
                        };
                    };
                };
            };
        }; // end while (npos > 2)

    range<Value_t *> raux1(dest.first, it_dest), raux2(it_dest, dest.last);
    if (pos[0] < pos[1])
        {
        return concat(raux1,
                      uninit_full_merge(raux2, vrange_input[pos[0]],
                                        vrange_input[pos[1]], comp));
        }
    else
        {
        return concat(raux1,
                      uninit_full_merge(raux2, vrange_input[pos[1]],
                                        vrange_input[pos[0]], comp));
        };
    }

///////////////////////////////////////////////////////////////////////////////
//
// Functions to do a stable merge of ranges, in a vector.
//
///////////////////////////////////////////////////////////////////////////////

/// Merge the ranges in the vector v_input with the full_merge4 function.
///        The v_output vector is used as auxiliary memory in the internal
///        process. The final results is in the dest range.
///        All the ranges of v_output are inside the range dest
/// @param dest : range where move the elements merged
/// @param v_input : vector of ranges to merge
/// @param v_output : vector of ranges obtained
/// @param comp : comparison object
/// @return range with all the elements moved
template <class Iter1_t, class Iter2_t, class Compare>
void merge_level4 (range<Iter1_t> dest,
                   std::vector<range<Iter2_t>> &v_input,
                   std::vector<range<Iter1_t>> &v_output, Compare comp)
    {
    typedef range<Iter1_t> range1_t;
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    v_output.clear();
    if (v_input.size() == 0) return;
    if (v_input.size() == 1) {
        v_output.emplace_back (init_move (dest, v_input[0]));
        return;
        };

    uint32_t nrange = static_cast<uint32_t>(v_input.size());
    uint32_t pos_ini = 0;
    while (pos_ini < v_input.size()) {
        uint32_t nmerge = (nrange + 3) >> 2;
        uint32_t nelem = (nrange + nmerge - 1) / nmerge;
        range1_t rz = full_merge4 (dest, &v_input[pos_ini], nelem, comp);
        v_output.emplace_back (rz);
        dest.first = rz.last;
        pos_ini += nelem;
        nrange -= nelem;
        };
    }

/// Merge the ranges moving the objects and constructing them in
///        uninitialized memory, in the vector v_input
///        using full_merge4. The v_output vector is used as auxiliary memory
///        in the internal process. The final results is in the dest range.
///        All the ranges of v_output are inside the range dest
///
/// @param dest : range where move the elements merged
/// @param v_input : vector of ranges to merge
/// @param v_output : vector of ranges obtained
/// @param comp : comparison object
/// @return range with all the elements moved and constructed
template <class Value_t, class Iter_t, class Compare>
void uninit_merge_level4 (range<Value_t *> dest,
                          std::vector<range<Iter_t>> &v_input,
                          std::vector<range<Value_t *>> &v_output,
                          Compare comp)
    {
    typedef range<Value_t *> range1_t;
    typedef typename std::iterator_traits<Iter_t>::value_type type1;
    static_assert(std::is_same<type1, Value_t>::value, "Incompatible iterators\n");

    v_output.clear();
    if (v_input.size() == 0) return;
    if (v_input.size() == 1) {
        v_output.emplace_back (uninit_move (dest, v_input[0]));
        return;
        };

    uint32_t nrange = static_cast<uint32_t>(v_input.size());
    uint32_t pos_ini = 0;
    while (pos_ini < v_input.size()) {
        uint32_t nmerge = (nrange + 3) >> 2;
        uint32_t nelem = (nrange + nmerge - 1) / nmerge;
        range1_t rz = uninit_full_merge4 (dest, &v_input[pos_ini], nelem, comp);
        v_output.emplace_back (rz);
        dest.first = rz.last;
        pos_ini += nelem;
        nrange -= nelem;
        };
    }

/// Merge the ranges in the vector v_input using the merge_level4
///        function. The v_output vector is used as auxiliary memory in the
///        internal process
///        The final results is in the range_output range.
///        All the ranges of v_output are inside the range range_output
///        All the ranges of v_input are inside the range range_input
/// @param range_input : range including all the ranges of v_input
/// @param ange_output : range including all the elements of v_output
/// @param v_input : vector of ranges to merge
/// @param v_output : vector of ranges obtained
/// @param comp : comparison object
/// @return range with all the elements moved
template <class Iter1_t, class Iter2_t, class Compare>
range<Iter2_t> merge_vector4 (range<Iter1_t> range_input, range<Iter2_t> range_output,
               std::vector<range<Iter1_t>> &v_input,
               std::vector<range<Iter2_t>> &v_output, Compare comp)
    {
    typedef range<Iter2_t> range2_t;
    typedef typename std::iterator_traits<Iter1_t>::value_type type1;
    typedef typename std::iterator_traits<Iter2_t>::value_type type2;
    static_assert(std::is_same<type1, type2>::value, "Incompatible iterators\n");

    v_output.clear();
    if (v_input.size() == 0) {
        return range2_t (range_output.first, range_output.first);
        };
    if (v_input.size() == 1) {
        return init_move (range_output, v_input[0]);
        };
    bool sw = false;
    uint32_t nrange = static_cast<uint32_t>(v_input.size());

    while (nrange > 1) {
        if (sw) {
            merge_level4 (range_input, v_output, v_input, comp);
            sw = false;
            nrange = static_cast<uint32_t>(v_input.size());
            }
        else
            {
            merge_level4 (range_output, v_input, v_output, comp);
            sw = true;
            nrange = static_cast<uint32_t>(v_output.size());
            };
        };
    return (sw) ? v_output[0] : init_move (range_output, v_input[0]);
    }

///////////////////////////////////////////////////////////////////////////////
//
// The number of bits of a number equal or greater than a given number
//
///////////////////////////////////////////////////////////////////////////////

/// An array storing the number of bits needed for to represent the first 256 numbers
static constexpr const uint32_t TMSB[256] = {
    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};

/// Obtain the number of bits of a number equal or greater than num
/// @param num : Number to examine
/// @return Number of bits
static inline uint32_t nbits32(uint32_t num) NOEXCEPT
    {
    int Pos = (num & 0xffff0000U) ? 16 : 0;
    if ((num >> Pos) & 0xff00U) Pos += 8;
    return (TMSB[num >> Pos] + Pos);
    }

/// Obtain the number of bits of a number equal or greater than num
/// @param num : Number to examine
/// @exception none
/// @return Number of bits
static inline uint32_t nbits64(uint64_t num)
    {
    uint32_t Pos = (num & 0xffffffff00000000ULL) ? 32 : 0;
    if ((num >> Pos) & 0xffff0000ULL) Pos += 16;
    if ((num >> Pos) & 0xff00ULL) Pos += 8;
    return (TMSB[num >> Pos] + Pos);
    }

///////////////////////////////////////////////////////////////////////////////
//
// Spin lock
//
///////////////////////////////////////////////////////////////////////////////

/// @class spinlock_t
/// Spin lock using atomic variable
class spinlock_t
    {
private:
    std::atomic_flag af;

public:

    explicit spinlock_t() NOEXCEPT
            : af()
        { af.clear(); };

    void lock() NOEXCEPT
        {
        if (af.test_and_set(std::memory_order_acquire))
            {
            std::this_thread::yield();
            while (af.test_and_set(std::memory_order_relaxed))
                {
                std::this_thread::yield();
                };
            };
        };

    bool try_lock() NOEXCEPT
        {
        return not af.test_and_set(std::memory_order_acquire);
        };

    void unlock() NOEXCEPT
        { af.clear(std::memory_order_release); };

    };

///////////////////////////////////////////////////////////////////////////////
//
// Concurrent stack
//
///////////////////////////////////////////////////////////////////////////////

/// @class stack_cnc
/// Concurrent stack
template <typename T, typename Allocator = std::allocator<T>>
class stack_cnc
    {
public:

    typedef std::vector<T, Allocator> vector_t;
    typedef typename vector_t::size_type size_type;
    typedef typename vector_t::difference_type difference_type;
    typedef typename vector_t::value_type value_type;
    typedef typename vector_t::pointer pointer;
    typedef typename vector_t::const_pointer const_pointer;
    typedef typename vector_t::reference reference;
    typedef typename vector_t::const_reference const_reference;
    typedef typename vector_t::allocator_type allocator_type;
    typedef Allocator alloc_t;

protected:

    vector_t v_t;
    mutable spinlock_t spl;

public:

    explicit stack_cnc() : v_t()
        {};

    stack_cnc(stack_cnc &&) = delete;

    virtual ~stack_cnc()
        { v_t.clear(); };

    /// Insert one element in the back of the container
    /// @param args : group of arguments for to build the object to insert. Can
    ///               be values, references or rvalues
    template <class... Args>
    void emplace_back(Args &&... args)
        {
        std::lock_guard<spinlock_t> guard(spl);
        v_t.emplace_back(std::forward<Args>(args)...);
        }

    /// If it exists, move the last element to P, and delete it
    /// @param P : reference to a variable where move the element
    /// @return  true  - Element moved and deleted
    ///          false - Empty stack_cnc
    bool pop_move_back(value_type &P)
        {
        std::lock_guard<spinlock_t> S(spl);
        if (v_t.size() == 0) return false;
        P = std::move(v_t.back());
        v_t.pop_back();
        return true;
        }

    }; // end class stack_cnc

///////////////////////////////////////////////////////////////////////////////
} // End namespace util
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// Forward Declarations
//
///////////////////////////////////////////////////////////////////////////////

template <class Iter_t, class Compare>
struct sample_sort;

template <class Iter_t, typename Compare>
void intro_sort(Iter_t first, Iter_t last, Compare comp);

namespace bis
{
class block_pos;

template <uint32_t Block_size, class Iter_t>
struct block;

template <uint32_t Block_size, class Iter_t, class Compare>
struct backbone;

template <uint32_t Block_size, class Iter_t, class Compare>
struct parallel_sort;

template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
struct move_blocks;

template <uint32_t Block_size, class Iter_t, class Compare>
struct compare_block_pos;

template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
struct merge_blocks;

}

/// @struct block_indirect_sort
/// This class is the entry point of the block indirect sort.
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare = util::compare_iter<Iter_t>>
struct block_indirect_sort
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;
    typedef std::atomic<uint32_t> atomic_t;
    typedef util::range<size_t> range_pos;
    typedef util::range<Iter_t> range_it;
    typedef util::range<value_t *> range_buf;
    typedef std::function<void(void)> function_t;

    // classes used in the internal operations of the algorithm
    typedef bis::block_pos block_pos_t;
    typedef bis::block<Block_size, Iter_t> block_t;
    typedef bis::backbone<Block_size, Iter_t, Compare> backbone_t;
    typedef bis::parallel_sort<Block_size, Iter_t, Compare> parallel_sort_t;

    typedef bis::merge_blocks<Block_size, Group_size, Iter_t, Compare> merge_blocks_t;
    typedef bis::move_blocks<Block_size, Group_size, Iter_t, Compare> move_blocks_t;
    typedef bis::compare_block_pos< Block_size, Iter_t, Compare> compare_block_pos_t;

    // contains the data and the internal data structures of the algorithm for
    // to be shared between the classes which are part of the algorithm
    backbone_t bk;
    // atomic counter for to detect the end of the works created inside the object
    atomic_t counter;
    // pointer to the uninitialized memory used for the thread buffers
    value_t *ptr;
    // indicate if the memory pointed by ptr is initialized
    bool construct;
    // range from extract the buffers for the threads
    range_buf rglobal_buf;
    // number of threads to use
    uint32_t nthread;

    block_indirect_sort (Iter_t first, Iter_t last, Compare cmp, uint32_t nthr);

    block_indirect_sort (Iter_t first, Iter_t last)
        : block_indirect_sort (first, last, Compare(),
                               std::thread::hardware_concurrency()){};

    block_indirect_sort (Iter_t first, Iter_t last, Compare cmp)
        : block_indirect_sort (first, last, cmp,
                               std::thread::hardware_concurrency()){};

    block_indirect_sort (Iter_t first, Iter_t last, uint32_t nthread)
        : block_indirect_sort (first, last, Compare(), nthread){};

    /// destructor all the data structures of the class (if the memory
    ///        is constructed, is destroyed) and  return the uninitialized
    ///        memory
    void destroy_all()
        {
        if (ptr != nullptr) {
            if (construct) {
                util::destroy (rglobal_buf);
                construct = false;
                };
            std::return_temporary_buffer (ptr);
            ptr = nullptr;
            };
        };

    /// destructor of the class (if the memory is constructed, is
    ///        destroyed) and  return the uninitialized memory
    ~block_indirect_sort() { destroy_all(); };

    void split_range (size_t pos_index1, size_t pos_index2,
                      uint32_t level_thread);

    void start_function();

    }; // End class block_indirect_sort

//
// NON INLINE block_indirect_sort FUNCTIONS
//

/// begin with the execution of the functions stored in works
/// @param first : iterator to the first element of the range to sort
/// @param last : iterator after the last element to the range to sort
/// @param comp : object for to compare two elements pointed by Iter_t
///               iterators
/// @param nthr : Number of threads to use in the process.When this value
///               is lower than 2, the sorting is done with 1 thread
template <uint32_t Block_size, uint32_t Group_size, class Iter_t,
    class Compare>
block_indirect_sort< Block_size, Group_size, Iter_t,
    Compare>::block_indirect_sort (Iter_t first, Iter_t last,
                                    Compare cmp, uint32_t nthr)
    : bk (first, last, cmp), counter (0), ptr (nullptr), construct (false),
      nthread (nthr)
    {
    try
        {
        assert ((last - first) >= 0);
        size_t nelem = size_t (last - first);
        if (nelem == 0) return;

        // check if sort
        bool sorted = true;
        for (Iter_t it1 = first, it2 = first + 1;
             it2 != last and (sorted = not bk.cmp (*it2, *it1)); it1 = it2++)
            ;
        if (sorted) return;

        // check if only single thread
        size_t nthreadmax = nelem / (Block_size * Group_size) + 1;
        if (nthread > nthreadmax) nthread = (uint32_t)nthreadmax;
        uint32_t nbits_size = (util::nbits64(sizeof(value_t))) >> 1;
        if (nbits_size > 5) nbits_size = 5;
        size_t max_per_thread = 1 << (18 - nbits_size);

        if (nelem < (max_per_thread) or nthread < 2) {
            intro_sort (first, last, bk.cmp);
            return;
            };

        // creation of the temporary buffer
        ptr = std::get_temporary_buffer<value_t> (Block_size * nthread).first;
        if (ptr == nullptr) {
            bk.error = true;
            throw std::bad_alloc();
            };

        rglobal_buf = range_buf (ptr, ptr + (Block_size * nthread));
        util::init (rglobal_buf, *first);
        construct = true;

        // creation of the buffers for the threads
        std::vector<value_t *> vbuf (nthread);
        for (uint32_t i = 0; i < nthread; ++i) {
            vbuf[i] = ptr + (i * Block_size);
            };

        // Insert the first work in the stack
        util::atomic_write (counter, 1);
        function_t f1 = [&]( ) {
            start_function();
            util::atomic_sub (counter, 1);
            };
        bk.works.emplace_back (f1);

        // Process
        std::vector<std::future< void>> vfuture (nthread);

        // The function launched with the futures is "execute the functions of
        // the stack until this->counter is zero
        // vbuf[i] is the memory from the main thread for to configure the
        // thread local buffer
        for (uint32_t i = 0; i < nthread; ++i) {
            auto f1 = [=, &vbuf]( ) { bk.exec (vbuf[i], this->counter); };
            vfuture[i] = std::async (std::launch::async, f1);
            };
        for (uint32_t i = 0; i < nthread; ++i) vfuture[i].get();
        if (bk.error) throw std::bad_alloc();
        }
    catch (std::bad_alloc &)
        {
        destroy_all();
        throw;
        }
    }

/// Splits a range of positions in the index, and
///        depending of the size, sort directly or make to a recursive call
///        to split_range
/// @param pos_index1 : first position in the index
/// @param pos_index2 : position after the last in the index
/// @param level_thread : depth of the call. When 0 sort the blocks
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
void block_indirect_sort< Block_size, Group_size, Iter_t, Compare>::split_range(
        size_t pos_index1,
        size_t pos_index2,
        uint32_t level_thread)
    {
    size_t nblock = pos_index2 - pos_index1;

    // In the blocks not sorted, the physical position is the logical position
    Iter_t first = bk.get_block (pos_index1).first;
    Iter_t last = bk.get_range (pos_index2 - 1).last;

    if (nblock < Group_size) {
        intro_sort (first, last, bk.cmp);
        return;
        };

    size_t pos_index_mid = pos_index1 + (nblock >> 1);
    atomic_t son_counter (1);

    // Insert in the stack the work for the second part, and the actual thread,
    // execute the first part
    if (level_thread != 0) {
        auto f1 = [=, &son_counter]( ) {
            split_range (pos_index_mid, pos_index2, level_thread - 1);
            util::atomic_sub (son_counter, 1);
            };
        bk.works.emplace_back (f1);
        if (bk.error) return;
        split_range (pos_index1, pos_index_mid, level_thread - 1);
        }
    else
        {
        Iter_t mid = first + ((nblock >> 1) * Block_size);
        auto f1 = [=, &son_counter]( ) {
            parallel_sort_t (bk, mid, last);
            util::atomic_sub (son_counter, 1);
            };
        bk.works.emplace_back (f1);
        if (bk.error) return;
        parallel_sort_t (bk, first, mid);
        };
    bk.exec (son_counter);
    if (bk.error) return;
    merge_blocks_t (bk, pos_index1, pos_index_mid, pos_index2);
    }

/// Initialize the process; when the number of threads is lower
/// than a predefined value, sort the elements with a parallel introsort.
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
void block_indirect_sort< Block_size, Group_size, Iter_t, Compare>::start_function()
    {
    if (nthread < SGM_BLOCK_INDIRECT_NTHREAD_BORDER) {
        parallel_sort_t (bk, bk.global_range.first, bk.global_range.last);
        }
    else
        {
        size_t level_thread = util::nbits64 (nthread - 1);
        split_range(0, bk.nblock, static_cast<uint32_t>(level_thread - 1));
        if (bk.error) return;
        move_blocks_t k (bk);
        };
    }

/// @struct spin_sort
///  This class implements stable sort algorithm with 1 thread, with
///  an auxiliary memory of N/2 elements
template <class Iter_t, typename Compare = util::compare_iter<Iter_t>>
class spin_sort
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;
    typedef util::range<Iter_t> range_it;
    typedef util::range<value_t *> range_buf;

    // When the number of elements to sort is smaller than Sort_min, are sorted
    // by the insertion sort algorithm
    static const uint32_t Sort_min = 36;

    // Pointer to the auxiliary memory
    value_t *ptr;

    // Number of elements in the auxiliary memory
    size_t nptr;

    // construct indicate if the auxiliary memory in initialized, and owner
    // indicate if the auxiliary memory had been created inside the object or
    // had been received as a parameter
    bool construct = false, owner = false;

    spin_sort (Iter_t first, Iter_t last, Compare comp, value_t *paux,
               size_t naux);

public:

    spin_sort (Iter_t first, Iter_t last, Compare comp = Compare())
        : spin_sort (first, last, comp, nullptr, 0){};

    spin_sort (Iter_t first, Iter_t last, Compare comp, range_buf range_aux)
        : spin_sort (first, last, comp, range_aux.first, range_aux.size()){};

    /// Destructor of the struct. Destroy the elements if construct is
    /// true, and return the memory if owner is true
    ~spin_sort()
        {
        if (construct) {
            destroy (util::range<value_t *> (ptr, ptr + nptr));
            construct = false;
            };
        if (owner and ptr != nullptr) std::return_temporary_buffer (ptr);
        };
    }; // End of class spin_sort

//
// Class spin_sort Non-inline functions
//

/// Constructor of the spin_sort struct.
//
/// @param first : iterator to the first element of the range to sort
/// @param last : iterator after the last element to the range to sort
/// @param comp : object for to compare two elements pointed by Iter_t
///               iterators
/// @param paux : pointer to the auxiliary memory provided. If nullptr, the
///               memory is created inside the class
/// @param naux : number of elements pointed by paux
template <class Iter_t, class Compare>
spin_sort< Iter_t, Compare>
::spin_sort (Iter_t first, Iter_t last, Compare comp, value_t *paux,
             size_t naux)
    : ptr (paux), nptr (naux), construct (false), owner (false)
    {
    util::range<Iter_t> range_input (first, last);
    assert (range_input.valid());

    size_t nelem = range_input.size();
    owner = construct = false;

    nptr = (nelem + 1) >> 1;
    size_t nelem_1 = nptr;
    size_t nelem_2 = nelem - nelem_1;

    if (nelem <= (Sort_min << 1)) {
        insertion_sort (range_input.first, range_input.last, comp);
        return;
        };
    // check if sort
    bool sw = true;
    for (Iter_t it1 = range_input.first, it2 = range_input.first + 1;
         it2 != range_input.last and (sw = not comp (*it2, *it1)); it1 = it2++)
        ;
    if (sw) return;

    if (ptr == nullptr) {
        ptr = std::get_temporary_buffer<value_t> (nptr).first;
        if (ptr == nullptr) throw std::bad_alloc();
        owner = true;
        };
    range_buf range_aux (ptr, (ptr + nptr));

    // Process
    uint32_t nlevel = util::nbits64 (((nelem + Sort_min - 1) / Sort_min) - 1) - 1;
    assert (nlevel != 0);

    if ((nlevel & 1) == 1) {
        // if the number of levels is odd, the data are in the first parameter
        // of range_sort, and the results appear in the second parameter
        range_it range_1 (first, first + nelem_2),
            range_2 (first + nelem_2, last);
        range_aux = uninit_move (range_aux, range_2);
        construct = true;

        range_sort (range_aux, range_2, comp, nlevel);
        range_buf rng_bx (range_aux.first, range_aux.first + nelem_2);

        range_sort (range_1, rng_bx, comp, nlevel);
        half_merge (range_input, rng_bx, range_2, comp);
        }
    else
        {
        // If the number of levels is even, the data are in the second
        // parameter of range_sort, and the results are in the same parameter
        range_it range_1 (first, first + nelem_1),
            range_2 (first + nelem_1, last);
        range_aux = uninit_move (range_aux, range_1);
        construct = true;

        range_sort (range_1, range_aux, comp, nlevel);

        range_1.last = range_1.first + range_2.size();
        range_sort (range_1, range_2, comp, nlevel);
        half_merge (range_input, range_aux, range_2, comp);
        };
    }

/// Heap sort algorithm
/// @remarks This algorithm is O(NLogN)
template <class Iter_t, class Compare>
struct heap_sort
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;

    /// Sort and signal the changes of three values
    /// @param val_0 : first value to compare
    /// @param val_1 : second value to compare
    /// @param val_2 : third value to compare
    /// @param [out] bool_0 : if true indicates val_0 had been changed
    /// @param [out] bool_1 : if true indicates val_1 had been changed
    /// @param [out] bool_2 : if true indicates val_2 had been changed
    /// @return if true , some value had changed
    /// @remarks
    bool sort3 (value_t &val_0, value_t &val_1, value_t &val_2, bool &bool_0,
                bool &bool_1, bool &bool_2)
        {
        bool_0 = bool_1 = bool_2 = false;
        int value = 0;
        if (val_0 < val_1) value += 4;
        if (val_1 < val_2) value += 2;
        if (val_0 < val_2) value += 1;

        switch (value)
            {
            case 0: break;

            case 2:
                std::swap (val_1, val_2);
                bool_1 = bool_2 = true;
                break;

            case 3:
                if (not(val_0 > val_1)) {
                    std::swap (val_0, val_2);
                    bool_0 = bool_2 = true;
                    }
                else
                    {
                    auto aux = std::move (val_2);
                    val_2 = std::move (val_1);
                    val_1 = std::move (val_0);
                    val_0 = std::move (aux);
                    bool_0 = bool_1 = bool_2 = true;
                    };
                break;

            case 4:
                std::swap (val_0, val_1);
                bool_0 = bool_1 = true;
                break;

            case 5:
                if (val_1 > val_2) {
                    auto aux = std::move (val_0);
                    val_0 = std::move (val_1);
                    val_1 = std::move (val_2);
                    val_2 = std::move (aux);
                    bool_0 = bool_1 = bool_2 = true;
                    }
                else
                    {
                    std::swap (val_0, val_2);
                    bool_0 = bool_2 = true;
                    };
                break;

            case 7:
                std::swap (val_0, val_2);
                bool_0 = bool_2 = true;
                break;

            default: abort();
            };
        return (bool_0 or bool_1 or bool_2);
        };

    /// Make the heap for to extract the sorted elements
    /// @param first : iterator to the first element of the range
    /// @param nelem : number of lements of the range
    /// @param comp : object for to compare two elements
    /// @remarks This algorithm is O(NLogN)
    void make_heap (Iter_t first, size_t nelem, Compare comp)
        {
        size_t pos_father, pos_son;
        Iter_t iter_father = first, iter_son = first;
        bool sw = false;

        for (size_t i = 1; i < nelem; ++i) {
            pos_father = i;
            iter_father = first + i;
            sw = false;
            do
                {
                iter_son = iter_father;
                pos_son = pos_father;
                pos_father = (pos_son - 1) >> 1;
                iter_father = first + pos_father;
                if ((sw = comp (*iter_father, *iter_son)))
                    std::swap (*iter_father, *iter_son);
                } while (sw and pos_father != 0);
            };
        };

    /// Heap sort algorithm
    /// @param first: iterator to the first element of the range
    /// @param last : iterator to the next element of the last in the range
    /// @param comp : object for to do the comparison between the elements
    /// @remarks This algorithm is O(NLogN)
    heap_sort (Iter_t first, Iter_t last, Compare comp)
        {
        assert ((last - first) >= 0);
        size_t nelem = last - first;
        if (nelem < 2) return;

        // Creating the initial heap
        make_heap (first, nelem, comp);

        //  Sort the heap
        size_t pos_father, pos_son;
        Iter_t iter_father = first, iter_son = first;

        bool sw = false;
        for (size_t i = 1; i < nelem; ++i) {
            std::swap (*first, *(first + (nelem - i)));
            pos_father = 0;
            pos_son = 1;
            iter_father = first;
            sw = true;
            while (sw and pos_son < (nelem - i)) {
                // if the father have two sons must select the bigger
                iter_son = first + pos_son;
                if ((pos_son + 1) < (nelem - i) and
                    comp (*iter_son, *(iter_son + 1)))
                    {
                    ++pos_son;
                    ++iter_son;
                    };
                if ((sw = comp (*iter_father, *iter_son)))
                    std::swap (*iter_father, *iter_son);
                pos_father = pos_son;
                iter_father = iter_son;
                pos_son = (pos_father << 1) + 1;
                };
            };
        };
    }; // End class heap_sort

/// less_ptr_no_null
/// @remarks this is the comparison object for pointers. Compare the objects
///          pointed by the iterators
template <class Iter_t, class Compare = util::compare_iter<Iter_t>>
struct less_ptr_no_null
    {

    Compare comp; // comparison object of the elements pointed by Iter_t

    /// constructor from a Compare object
    /// @param C1 : comparison object

    inline explicit less_ptr_no_null (Compare C1 = Compare()) : comp (C1){};

    /// Make the comparison of the objects pointed by T1 and T2, using
    //         the internal comp
    //
    /// @param  T1 : first iterator
    /// @param  T2 : second iterator
    /// @return bool result of the comparison

    inline bool operator( ) (Iter_t T1, Iter_t T2) const
        {
        return comp (*T1, *T2);
        };
    };

/// From a vector of objects, create a vector of iterators to
///        the objects.
/// @param first : iterator to the first element of the range
/// @param last : iterator to the element after the last of the range
/// @param index : vector where store the iterators
template <class Iter_t>
void create_index (Iter_t first, Iter_t last, std::vector<Iter_t> &index)
    {
    auto nelem = last - first;
    assert (nelem >= 0);
    index.clear();
    index.reserve (nelem);
    for (; first != last; ++first) index.push_back (first);
    }

/// This function transform a logical sort of the elements in the index
///        in a physical sort
/// @param global_first : iterator to the first element of the data
/// @param [in] index : vector of the iterators
template <class Iter_t>
void sort_index (Iter_t global_first, std::vector<Iter_t> &index)
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;

    size_t pos_dest = 0;
    size_t pos_src = 0;
    size_t pos_in_vector = 0;
    size_t nelem = index.size();
    Iter_t it_dest, it_src;

    while (pos_in_vector < nelem) {
        while (pos_in_vector < nelem and
               (size_t (index[pos_in_vector] - global_first)) == pos_in_vector)
            {
            ++pos_in_vector;
            };

        if (pos_in_vector == nelem) return;
        pos_dest = pos_src = pos_in_vector;
        it_dest = global_first + pos_dest;
        value_t Aux = std::move (*it_dest);

        while ((pos_src = (size_t (index[pos_dest] - global_first))) !=
               pos_in_vector)
            {
            index[pos_dest] = it_dest;
            it_src = global_first + pos_src;
            *it_dest = std::move (*it_src);
            it_dest = it_src;
            pos_dest = pos_src;
            };

        *it_dest = std::move (Aux);
        index[pos_dest] = it_dest;
        ++pos_in_vector;
        };
    }

/// Insertion sort algorithm
/// @param first: iterator to the first element of the range
/// @param last : iterator to the next element of the last in the range
/// @param comp : object for to do the comparison between the elements
/// @remarks This algorithm is O(N²)
template <class Iter_t, typename Compare>
void insertion_sort (Iter_t first, Iter_t last, Compare comp)
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;

    if ((last - first) < 2) return;

    for (Iter_t it_examine = first + 1; it_examine != last; ++it_examine) {
        value_t Aux = std::move (*it_examine);
        Iter_t it_insertion = it_examine;

        while (it_insertion != first and comp (Aux, *(it_insertion - 1))) {
            *it_insertion = std::move (*(it_insertion - 1));
            --it_insertion;
            };
        *it_insertion = std::move (Aux);
        };
    }

using util::compare_iter;
using util::nbits64;

/// Return the iterator to the mid value of the three values passsed
///          as parameters
/// @param iter_1 : iterator to the first value
/// @param iter_2 : iterator to the second value
/// @param iter_3 : iterator to the third value
/// @param comp : object for to compare two values
/// @return iterator to mid value
template <typename Iter_t, typename Compare>
inline Iter_t mid3 (Iter_t iter_1, Iter_t iter_2, Iter_t iter_3, Compare comp)
    {
    return comp (*iter_1, *iter_2)
           ? (comp (*iter_2, *iter_3)
              ? iter_2
              : (comp (*iter_1, *iter_3) ? iter_3 : iter_1))
           : (comp (*iter_3, *iter_2)
              ? iter_2
              : (comp (*iter_3, *iter_1) ? iter_3 : iter_1));
    }

/// Receive a range between first and last, calcule the mid iterator
///          with the first, the previous to the last, and the central
///          position. With this mid iterator swap with the first position
/// @param first : iterator to the first element
/// @param last : iterator to the last element
/// @param comp : object for to compare two elements
template <class Iter_t, class Compare>
inline void pivot3 (Iter_t first, Iter_t last, Compare comp)
    {
    auto N2 = (last - first) >> 1;
    Iter_t it_val = mid3 (first + 1, first + N2, last - 1, comp);
    std::swap (*first, *it_val);
    }

/// Return the iterator to the mid value of the nine values passsed
///          as parameters
/// @param iter_1 : iterator to the first value
/// @param iter_2 : iterator to the second value
/// @param iter_3 : iterator to the third value
/// @param iter_4 : iterator to the fourth value
/// @param iter_5 : iterator to the fifth value
/// @param iter_6 : iterator to the sixth value
/// @param iter_7 : iterator to the seventh value
/// @param iter_8 : iterator to the eighth value
/// @param iter_9 : iterator to the ninth value
/// @return iterator to the mid value
template <class Iter_t, class Compare>
inline Iter_t mid9 (Iter_t iter_1, Iter_t iter_2, Iter_t iter_3, Iter_t iter_4,
                    Iter_t iter_5, Iter_t iter_6, Iter_t iter_7, Iter_t iter_8,
                    Iter_t iter_9, Compare comp)
    {
    return mid3 (mid3 (iter_1, iter_2, iter_3, comp),
                 mid3 (iter_4, iter_5, iter_6, comp),
                 mid3 (iter_7, iter_8, iter_9, comp), comp);
    }

/// Receive a range between first and last, obtain 9 values between
///          the elements  including the first and the previous to the last.
///          Obtain the iterator to the mid value and swap with the first
///          position
/// @param first : iterator to the first element
/// @param last : iterator to the last element
/// @param comp : object for to compare two elements
template <class Iter_t, class Compare>
inline void pivot9 (Iter_t first, Iter_t last, Compare comp)
    {
    size_t cupo = (last - first) >> 3;
    Iter_t itaux = mid9 (first + 1, first + cupo, first + 2 * cupo,
                         first + 3 * cupo, first + 4 * cupo, first + 5 * cupo,
                         first + 6 * cupo, first + 7 * cupo, last - 1, comp);
    std::swap (*first, *itaux);
    }

/// Internal function for to divide and sort the ranges
//
/// @param first : iterator to the first element
/// @param last : iterator to the element after the last in the range
/// @param level : level of depth from the top level call
/// @param comp : object for to Compare elements
template <class Iter_t, typename Compare>
void intro_sort_internal (Iter_t first, Iter_t last, uint32_t level,
                          Compare comp)
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;

    const uint32_t nmin = 32;
    size_t nelem = last - first;
    if (nelem < nmin) return insertion_sort (first, last, comp);

    if (level == 0) {
        heap_sort< Iter_t, Compare> (first, last, comp);
        return;
        };

    pivot3 (first, last, comp);

    const value_t &val = const_cast<value_t &> (*first);
    Iter_t c_first = first + 1, c_last = last - 1;

    while (comp (*c_first, val)) ++c_first;
    while (comp (val, *c_last)) --c_last;

    while (not(c_first > c_last)) {
        std::swap (*(c_first++), *(c_last--));
        while (comp (*c_first, val)) ++c_first;
        while (comp (val, *c_last)) --c_last;
        }; // End while

    std::swap (*first, *c_last);
    intro_sort_internal (first, c_last, level - 1, comp);
    intro_sort_internal (c_first, last, level - 1, comp);
    }

/// Function for to sort range [first, last )
/// @param first : iterator to the first element
/// @param last : iterator to the element after the last in the range
/// @param comp : object for to compare elements
template <class Iter_t, typename Compare>
void intro_sort (Iter_t first, Iter_t last, Compare comp)
    {
    auto nelem = last - first;
    assert (nelem >= 0);

    // check if sort
    bool sw = true;
    for (Iter_t it1 = first, it2 = first + 1;
         it2 != last and (sw = not comp (*it2, *it1)); it1 = it2++)
        ;
    if (sw) return;

    uint32_t level = ((nbits64 (nelem) - 4) * 3) / 2;
    intro_sort_internal (first, last, level, comp);
    }

/// @struct parallel_stable_sort
/// This a structure for to implement a parallel stable sort, exception safe
template <class Iter_t, class Compare = util::compare_iter<Iter_t>>
struct parallel_stable_sort
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;

    // Number of elements to sort
    size_t nelem;
    // Pointer to the auxiliary memory needed for the algorithm
    value_t *ptr;
    // Minimal number of elements for to be sorted in parallel mode
    const size_t nelem_min = 1 << 16;

    parallel_stable_sort(Iter_t first, Iter_t last)
        : parallel_stable_sort (first, last, Compare(),
                                std::thread::hardware_concurrency()){};

    parallel_stable_sort(Iter_t first, Iter_t last, Compare cmp)
        : parallel_stable_sort (first, last, cmp,
                                std::thread::hardware_concurrency()){};

    parallel_stable_sort(Iter_t first, Iter_t last, uint32_t num_thread)
        : parallel_stable_sort(first, last, Compare(), num_thread) {};

    parallel_stable_sort(Iter_t first, Iter_t last, Compare cmp, uint32_t num_thread);

    /// The utility is to destroy the temporary buffer used in the
    ///        sorting process
    void destroy_all()
        {
        if (ptr != nullptr) std::return_temporary_buffer (ptr);
        };

    /// Destructor of the class. The utility is to destroy the temporary
    ///        buffer used in the sorting process
    ~parallel_stable_sort() { destroy_all(); };

    }; // end struct parallel_stable_sort

//
// Non-inline parallel_stable_sort functions
//

using util::range;

/// Constructor
///
/// @param first : iterator to the first element of the range to sort
/// @param last : iterator after the last element to the range to sort
/// @param cmp : object for to compare two elements pointed by Iter_t
///                    iterators
/// @param num_thread : Number of threads to use in the process. When this value
///                  is lower than 2, the sorting is done with 1 thread
template <class Iter_t, class Compare>
parallel_stable_sort< Iter_t, Compare>::parallel_stable_sort(
    Iter_t first, Iter_t last, Compare cmp, uint32_t num_thread)
        : nelem (0), ptr (nullptr)
    {
    util::range<Iter_t> range_initial (first, last);
    assert (range_initial.valid());

    nelem = range_initial.size();
    size_t nptr = (nelem + 1) >> 1;

    if (nelem < nelem_min or num_thread < 2) {
        spin_sort<Iter_t,Compare>(range_initial.first, range_initial.last, cmp);
        return;
        };

    // check if sort
    bool sw = true;
    for (Iter_t it1 = range_initial.first, it2 = range_initial.first + 1;
         it2 != range_initial.last and (sw = not cmp (*it2, *it1));
         it1 = it2++)
        ;
    if (sw) return;

    ptr = std::get_temporary_buffer<value_t> (nptr).first;
    if (ptr == nullptr) throw std::bad_alloc();

    // Parallel Process

    range<Iter_t> range_first (range_initial.first,
                                 range_initial.first + nptr);

    range<Iter_t> range_second (range_initial.first + nptr,
                                  range_initial.last);

    range<value_t *> range_buffer (ptr, ptr + nptr);

    try
        {
        sample_sort< Iter_t, Compare> (range_initial.first,
                                        range_initial.first + nptr, cmp,
                                        num_thread, range_buffer);
        }
    catch (std::bad_alloc &)
        {
        destroy_all();
        throw std::bad_alloc();
        };

    try
        {
        sample_sort< Iter_t, Compare> (range_initial.first + nptr,
                                        range_initial.last, cmp, num_thread,
                                        range_buffer);
        }
    catch (std::bad_alloc &)
        {
        destroy_all();
        throw std::bad_alloc();
        };

    range_buffer = init_move (range_buffer, range_first);
    range_initial = half_merge (range_initial, range_buffer, range_second, cmp);

    } // end of constructor

/// @struct sample_sort
/// This a structure for to implement a sample sort, exception safe
template <class Iter_t, class Compare>
struct sample_sort
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;
    typedef range<Iter_t> range_it;
    typedef range<value_t *> range_buf;
    typedef sample_sort< Iter_t, Compare> this_t;
    typedef spin_sort< Iter_t, Compare> spin_sort_t;

    // minimun numbers of elements for to be sortd in parallel mode
    static const uint32_t thread_min = (1 << 16);

    // Number of threads to use in the algorithm
    // Number of intervals for to do the internal division of the data
    uint32_t nthread, ninterval;

    // Bool variables indicating if the auxiliary memory is constructed
    // and indicating in the auxiliary memory had been obtained inside the
    /// algorithm or had been received as a parameter
    bool construct = false, owner = false;

    // Comparison object for to compare two elements
    Compare comp;

    // Range with all the elements to sort
    range_it global_range;

    // range with the auxiliary memory
    range_buf global_buf;

    // vector of futures
    std::vector<std::future< void>> vfuture;

    // vector of vectors which contains the ranges to merge obtained in the
    // subdivision
    std::vector<std::vector<range_it>> vv_range_it;

    // each vector of ranges of the vv_range_it, need their corresponding buffer
    // for to do the merge
    std::vector<std::vector<range_buf>> vv_range_buf;

    // Initial vector of ranges
    std::vector<range_it> vrange_it_ini;

    // Initial vector of buffers
    std::vector<range_buf> vrange_buf_ini;

    // atomic counter for to know when are finished the function_t created
    // inside a function
    std::atomic<uint32_t> njob;

    // Indicate if an error in the algorithm for to undo all
    bool error;

    void initial_configuration();

    sample_sort (Iter_t first, Iter_t last, Compare cmp, uint32_t num_thread, value_t *paux, size_t naux);

    sample_sort (Iter_t first, Iter_t last)
        : sample_sort (first, last, Compare(), std::thread::hardware_concurrency(), nullptr, 0)
        {};

    sample_sort (Iter_t first, Iter_t last, Compare cmp)
        : sample_sort (first, last, cmp, std::thread::hardware_concurrency(), nullptr, 0)
        {};

    sample_sort (Iter_t first, Iter_t last, uint32_t num_thread)
        : sample_sort (first, last, Compare(), num_thread, nullptr, 0)
        {};

    sample_sort (Iter_t first, Iter_t last, Compare cmp, uint32_t num_thread)
        : sample_sort (first, last, cmp, num_thread, nullptr, 0)
        {};

    sample_sort (Iter_t first, Iter_t last, Compare cmp, uint32_t num_thread, range_buf range_buf_initial)
        : sample_sort (first, last, cmp, num_thread, range_buf_initial.first, range_buf_initial.size())
        {};

    void destroy_all();

    /// destructor of the class. The utility is to destroy the temporary
    ///        buffer used in the sorting process
    ~sample_sort() { destroy_all(); };

    /// Assign to each thread in the first merge
    void execute_first()
        {
        uint32_t job = 0;
        while ((job = util::atomic_add (njob, 1)) < ninterval) {
            uninit_merge_level4 (vrange_buf_ini[job], vv_range_it[job],
                                 vv_range_buf[job], comp);
            };
        };

    /// Assign each thread the final merge
    void execute()
        {
        uint32_t job = 0;
        while ((job = util::atomic_add (njob, 1)) < ninterval) {
            merge_vector4 (vrange_buf_ini[job], vrange_it_ini[job],
                           vv_range_buf[job], vv_range_it[job], comp);
            };
        };

    /// Implement the merge of the initially sparse ranges

    void first_merge()
        {
        njob = 0;

        for (uint32_t i = 0; i < nthread; ++i) {
            vfuture[i] =
                std::async (std::launch::async, &this_t::execute_first, this);
            };
        for (uint32_t i = 0; i < nthread; ++i) vfuture[i].get();
        };

    /// Implement the final merge of the ranges
    void final_merge()
        {
        njob = 0;

        for (uint32_t i = 0; i < nthread; ++i) {
            vfuture[i] =
                std::async (std::launch::async, &this_t::execute, this);
            };
        for (uint32_t i = 0; i < nthread; ++i) vfuture[i].get();
        };

    }; //                    End class sample_sort

//
// Non-inline sample_sort methods
//

/// Constructor
///
/// @param first : iterator to the first element of the range to sort
/// @param last : iterator after the last element to the range to sort
/// @param cmp : object for to compare two elements pointed by Iter_t iterators
/// @param num_thread : Number of threads to use in the process. When this value
///                     is lower than 2, the sorting is done with 1 thread
/// @param paux : pointer to the auxiliary memory. If nullptr, the memory is
///               created inside the class
/// @param naux : number of elements of the memory pointed by paux
template <class Iter_t, typename Compare>
sample_sort< Iter_t, Compare>::sample_sort (Iter_t first, Iter_t last, Compare cmp, uint32_t num_thread,
               value_t *paux, size_t naux)
    : nthread (num_thread), owner (false), comp (cmp),
      global_range (first, last), global_buf (nullptr, nullptr), error (false)
    {
    assert ((last - first) >= 0);
    size_t nelem = size_t (last - first);
    construct = false;
    njob = 0;
    vfuture.resize (nthread);

    // Adjust when have many threads and only a few elements
    while (nelem > thread_min and (nthread * nthread) > (nelem >> 3)) {
        nthread /= 2;
        };
    ninterval = (nthread << 3);

    if (nthread < 2 or nelem <= (thread_min)) {
        spin_sort< Iter_t, Compare> (first, last, comp);
        return;
        };

    // check if sort
    bool sw = true;
    for (Iter_t it1 = first, it2 = first + 1;
         it2 != last and (sw = not comp (*it2, *it1)); it1 = it2++)
        ;
    if (sw) return;

    if (paux != nullptr) {
        assert (naux != 0);
        global_buf.first = paux;
        global_buf.last = paux + naux;
        owner = false;
        }
    else
        {
        value_t *ptr = std::get_temporary_buffer<value_t> (nelem).first;
        if (ptr == nullptr) throw std::bad_alloc();
        owner = true;
        global_buf = range_buf (ptr, ptr + nelem);
        };

    // PROCESS
    try
        {
        initial_configuration();
        }
    catch (std::bad_alloc &)
        {
        error = true;
        };
    if (not error) {
        first_merge();
        construct = true;
        final_merge();
        };
    if (error) {
        destroy_all();
        throw std::bad_alloc();
        };
    }

/// Destructor, destroy the temporary buffer used in the sorting process
template <class Iter_t, typename Compare>
void sample_sort< Iter_t, Compare>::destroy_all()
    {
    if (construct) {
        destroy (global_buf);
        construct = false;
        }
    if (global_buf.first != nullptr and owner)
        std::return_temporary_buffer (global_buf.first);
    }

/// Create the internal data structures, and obtain the inital set of
/// ranges to merge
template <class Iter_t, typename Compare>
void sample_sort< Iter_t, Compare>::initial_configuration()
    {
    std::vector<range_it> vmem_thread;
    std::vector<range_buf> vbuf_thread;
    size_t nelem = global_range.size();

    size_t cupo = nelem / nthread;
    Iter_t it_first = global_range.first;
    value_t *buf_first = global_buf.first;
    vmem_thread.reserve (nthread + 1);
    vbuf_thread.reserve (nthread + 1);

    for (uint32_t i = 0; i < (nthread - 1);
         ++i, it_first += cupo, buf_first += cupo)
        {
        vmem_thread.emplace_back (it_first, it_first + cupo);
        vbuf_thread.emplace_back (buf_first, buf_first + cupo);
        };

    vmem_thread.emplace_back (it_first, global_range.last);
    vbuf_thread.emplace_back (buf_first, global_buf.last);

    // Sorting of the ranges
    std::vector<std::future< void>> vfuture (nthread);

    for (uint32_t i = 0; i < nthread; ++i) {
        auto func = [=]( ) {
            spin_sort_t (vmem_thread[i].first, vmem_thread[i].last, comp,
                         vbuf_thread[i]);
            };
        vfuture[i] = std::async (std::launch::async, func);
        };

    for (uint32_t i = 0; i < nthread; ++i) vfuture[i].get();

    // Obtain the vector of milestones
    std::vector<Iter_t> vsample;
    vsample.reserve (nthread * (ninterval - 1));

    for (uint32_t i = 0; i < nthread; ++i) {
        size_t distance = vmem_thread[i].size() / ninterval;
        for (size_t j = 1, pos = distance; j < ninterval; ++j, pos += distance)
            {
            vsample.push_back (vmem_thread[i].first + pos);
            };
        };
    typedef less_ptr_no_null< Iter_t, Compare> compare_ptr;
    typedef typename std::vector<Iter_t>::iterator it_to_it;

    spin_sort< it_to_it, compare_ptr> (vsample.begin(), vsample.end(),
                                        compare_ptr (comp));

    // Create the final milestone vector
    std::vector<Iter_t> vmilestone;
    vmilestone.reserve (ninterval);

    for (uint32_t pos = nthread >> 1; pos < vsample.size(); pos += nthread) {
        vmilestone.push_back (vsample[pos]);
        };

    // Creation of the first vector of ranges
    std::vector<std::vector<range<Iter_t>>> vv_range_first (nthread);

    for (uint32_t i = 0; i < nthread; ++i) {
        Iter_t itaux = vmem_thread[i].first;

        for (uint32_t k = 0; k < (ninterval - 1); ++k) {
            Iter_t it2 = std::upper_bound (itaux, vmem_thread[i].last,
                                           *vmilestone[k], comp);

            vv_range_first[i].emplace_back (itaux, it2);
            itaux = it2;
            };
        vv_range_first[i].emplace_back (itaux, vmem_thread[i].last);
        };

    // Copy in buffer and creation of the final matrix of ranges
    vv_range_it.resize (ninterval);
    vv_range_buf.resize (ninterval);
    vrange_it_ini.reserve (ninterval);
    vrange_buf_ini.reserve (ninterval);

    for (uint32_t i = 0; i < ninterval; ++i) {
        vv_range_it[i].reserve (nthread);
        vv_range_buf[i].reserve (nthread);
        };

    Iter_t it = global_range.first;
    value_t *it_buf = global_buf.first;

    for (uint32_t k = 0; k < ninterval; ++k) {
        size_t nelem_interval = 0;

        for (uint32_t i = 0; i < nthread; ++i) {
            size_t nelem_range = vv_range_first[i][k].size();
            if (nelem_range != 0) {
                vv_range_it[k].push_back (vv_range_first[i][k]);
                };
            nelem_interval += nelem_range;
            };

        vrange_it_ini.emplace_back (it, it + nelem_interval);
        vrange_buf_ini.emplace_back (it_buf, it_buf + nelem_interval);

        it += nelem_interval;
        it_buf += nelem_interval;
        };
    }

using SGMInternal::detail::util::TMSB;

///  Select the block size in the block_indirect_sort
///  algorithm depending of the type and size of the data to sort
template <class Iter_t, class Compare, util::enable_if_string< util::value_iter< Iter_t>> * = nullptr>
void select_block_indirect (Iter_t first, Iter_t last, Compare cmp, uint32_t nthr = std::thread::hardware_concurrency())
    {
    block_indirect_sort< 128, 128, Iter_t, Compare> (first, last, cmp, nthr);
    }

template <size_t Size>
struct block_size
    {
    static constexpr const uint32_t BitsSize =
        (Size == 0) ? 0 : (Size > 256) ? 9 : TMSB[Size - 1];
    static constexpr const uint32_t sz[10] = {4096, 4096, 4096, 4096, 2048,
                                              1024, 768,  512,  256,  128};
    static constexpr const uint32_t data = sz[BitsSize];
    };

/// Select the block size in the block_indirect_sort
/// algorithm depending of the type and size of the data to sort
template <class Iter_t, class Compare, util::enable_if_not_string< util::value_iter< Iter_t>>* = nullptr>
void select_block_indirect (Iter_t first, Iter_t last, Compare cmp, uint32_t nthr = std::thread::hardware_concurrency())
    {
    block_indirect_sort<block_size< sizeof(util::value_iter< Iter_t>)>::data,
        28, Iter_t, Compare> (first, last, cmp, nthr);
    }

using util::nbits64;
using std::iterator_traits;

/// Divide r_input in two parts, sort it,and merge moving
///        the elements to range_buf.
/// @param range_input : range with the elements to sort
/// @param range_buffer : range with the elements sorted
/// @param comp : object for to compare two elements
/// @param level : when is 1, sort with the insertion_sort algorithm
///                if not make a recursive call splitting the ranges
template <class Iter1_t, class Iter2_t, class Compare>
void range_sort (const range<Iter1_t> &range_input,
                 const range<Iter2_t> &range_buffer, Compare comp,
                 uint32_t level)
    {
    typedef range<Iter1_t> range_it1;
    typedef range<Iter2_t> range_it2;
    assert (range_input.size() == range_buffer.size() and level != 0);

    size_t nelem1 = (range_input.size() + 1) >> 1;
    range_it1 range_input1 (range_input.first, range_input.first + nelem1),
        range_input2 (range_input.first + nelem1, range_input.last);

    if (level < 2) {
        insertion_sort (range_input1.first, range_input1.last, comp);
        insertion_sort (range_input2.first, range_input2.last, comp);
        }
    else
        {
        range_sort (range_it2 (range_buffer.first, range_buffer.first + nelem1),
                    range_input1, comp, level - 1);

        range_sort (range_it2 (range_buffer.first + nelem1, range_buffer.last),
                    range_input2, comp, level - 1);
        };

    full_merge (range_buffer, range_input1, range_input2, comp);
    }

///////////////////////////////////////////////////////////////////////////////
//
// Namespace bis, the block indirect sort implementation
//
///////////////////////////////////////////////////////////////////////////////
namespace bis
{

using SGMInternal::detail::util::range;

/// @struct block_pos
/// represent a pair of values, a position represented as an unsigned
///        variable ( position ), and a bool variable ( side ). They are packed
///        in a size_t variable. The Least Significant Bit is the bool variable,
///        and the others bits are the position
class block_pos
    {
    size_t num; // number which store a position and a bool side

public:

    block_pos() : num (0){};

    /// Constructor from a position and a side
    /// @param position : position to sotre
    /// @param side : side to store

    explicit block_pos (size_t position, bool side = false)
        {
        num = (position << 1) + ((side) ? 1 : 0);
        };

    /// Obtain the position stored inside the block_pos
    /// @return position
    size_t pos() const { return (num >> 1); };

    /// store a position inside the block_pos
    /// @param position : value to store
    void set_pos (size_t position) { num = (position << 1) + (num & 1); };

    /// obtain the side stored inside the block_pos
    /// @return bool value
    bool side() const { return ((num & 1) != 0); };

    /// store a bool value the block_pos
    /// @param sd : bool value to store
    void set_side (bool sd) { num = (num & ~1) + ((sd) ? 1 : 0); };

    }; // end struct block_pos

/// @struct block
/// represent a group of Block_size contiguous elements, beginning
///        with the pointed by first
template <uint32_t Block_size, class Iter_t>
struct block
    {
    Iter_t first; // iterator to the first element of the block

    /// constructor from an iterator to the first element of the block
    /// @param it : iterator to the first element of the block
    explicit block (Iter_t it) : first (it){};

    /// convert a block in a range
    /// @return range
    range<Iter_t> get_range()
        {
        return range_it (first, first + Block_size);
        };

    }; // end struct block

/// compare two blocks using the content of the pointed by first
/// @param block1 : first block to compare
/// @param block2 : second block to compare
/// @param cmp : comparison operator
template <uint32_t Block_size, class Iter_t, class Compare>
bool compare_block (block<Block_size, Iter_t> block1,
                    block<Block_size, Iter_t> block2,
                    Compare cmp = Compare())
    {
    return cmp (*block1.first, *block2.first);
    }

/// Compare two block_pos objects
template <uint32_t Block_size, class Iter_t, class Compare>
struct compare_block_pos
    {
    Iter_t global_first; // iterator to the first element to sort
    Compare comp;        // comparison object for to compare two elements

    /// constructor
    /// @param g_first : itertor to the first element to sort
    /// @param cmp : comparison operator
    compare_block_pos (Iter_t g_first, Compare cmp)
        : global_first (g_first), comp (cmp){};

    /// compare two blocks using the content of the pointed by
    ///        global_first
    /// @param block_pos1 : first block to compare
    /// @param block_pos2 : second block to compare
    bool operator( ) (block_pos block_pos1, block_pos block_pos2) const
        {
        return comp (*(global_first + (block_pos1.pos() * Block_size)),
                     *(global_first + (block_pos2.pos() * Block_size)));
        };

    }; // end struct compare_block_pos

using SGMInternal::detail::util::stack_cnc;

/// @struct backbone
/// This contains all the information shared betwen the classes of the
///        block indirect sort algorithm
template <uint32_t Block_size, class Iter_t, class Compare>
struct backbone
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;
    typedef std::atomic<uint32_t> atomic_t;
    typedef range<size_t> range_pos;
    typedef range<Iter_t> range_it;
    typedef range<value_t *> range_buf;
    typedef std::function<void(void)> function_t;
    typedef block<Block_size, Iter_t> block_t;

    // range with all the element to sort
    util::range<Iter_t> global_range;

    // index vector of block_pos elements
    std::vector<block_pos> index;

    // Number of elements to sort
    size_t nelem;

    // Number of blocks to sort
    size_t nblock;

    // Number of elements in the last block (tail)
    size_t ntail;

    // object for to compare two elements
    Compare cmp;

    // range  of elements of the last block (tail)
    range_it range_tail;

    // thread local varible. It is a pointer to the buffer
    static thread_local value_t *buf;

    // concurrent stack where store the function_t elements
    stack_cnc< function_t> works;

    // global indicator of error
    bool error;

    /// Constructor
    backbone (Iter_t first, Iter_t last, Compare comp);

    /// obtain the block in the position pos
    /// @param pos : position of the range
    /// @return block required
    block_t get_block (size_t pos) const
        {
        return block_t (global_range.first + (pos * Block_size));
        };

    /// obtain the range in the position pos
    /// @param pos : position of the range
    /// @return range required
    range_it get_range (size_t pos) const
        {
        Iter_t it1 = global_range.first + (pos * Block_size);
        Iter_t it2 =
            (pos == (nblock - 1)) ? global_range.last : it1 + Block_size;
        return range_it (it1, it2);
        };

    /// obtain the auxiliary buffer of the thread
    range_buf get_range_buf() const
        {
        return range_buf (buf, buf + Block_size);
        };

    /// Initialize the thread local buffer with the ptr_buf pointer,
    ///        and begin with the execution of the functions stored in works
    //
    /// @param ptr_buf : Pointer to the memory assigned to the thread_local
    ///                  buffer
    /// @param counter : atomic counter for to invoke to the exec function
    ///                  with only 1 parameter
    void exec (value_t *ptr_buf, atomic_t &counter)
        {
        buf = ptr_buf;
        exec (counter);
        };

    void exec (atomic_t &counter);

    }; // end struct backbone

//
// Non-inline backbone methods
//

/// initialization of the thread_local pointer to the auxiliary buffer
template <uint32_t Block_size, class Iter_t, class Compare>
thread_local typename std::iterator_traits<Iter_t>::value_type
    *backbone<Block_size, Iter_t, Compare>::buf = nullptr;

/// constructor of the class
//
/// @param first : iterator to the first element of the range to sort
/// @param last : iterator after the last element to the range to sort
/// @param comp : object for to compare two elements pointed by Iter_t
///               iterators
template <uint32_t Block_size, class Iter_t, class Compare>
backbone<Block_size, Iter_t, Compare>
::backbone (Iter_t first, Iter_t last, Compare comp)
    : global_range (first, last), cmp (comp), error (false)
    {
    assert ((last - first) >= 0);
    if (first == last) return; // nothing to do

    nelem = size_t (last - first);
    nblock = (nelem + Block_size - 1) / Block_size;
    ntail = (nelem % Block_size);
    index.reserve (nblock + 1);

    for (size_t i = 0; i < nblock; ++i) index.emplace_back (block_pos (i));

    range_tail.first =
        (ntail == 0) ? last : (first + ((nblock - 1) * Block_size));
    range_tail.last = last;
    }

/// execute the function_t stored in works, until counter is zero
/// @param counter : atomic counter. When 0 exits the function
template <uint32_t Block_size, class Iter_t, class Compare>
void backbone<Block_size, Iter_t, Compare>::exec (atomic_t &counter)
    {
    function_t func_exec;
    while (util::atomic_read (counter) != 0) {
        if (works.pop_move_back (func_exec))
            func_exec();
        else
            std::this_thread::yield();
        };
    }

/// @struct merge_blocks
/// This class merge the blocks. The blocks to merge are defined by two
///        ranges of positions in the index of the backbone
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
struct merge_blocks
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;
    typedef std::atomic<uint32_t> atomic_t;
    typedef util::range<size_t> range_pos;
    typedef util::range<Iter_t> range_it;
    typedef util::range<value_t *> range_buf;
    typedef std::function<void(void)> function_t;
    typedef backbone<Block_size, Iter_t, Compare> backbone_t;
    typedef compare_block_pos< Block_size, Iter_t, Compare>
        compare_block_pos_t;

    // Object with the elements to sort and all internal data structures of the
    // algorithm
    backbone_t &bk;

    merge_blocks (backbone_t &bkb, size_t pos_index1, size_t pos_index2,
                  size_t pos_index3);

    void tail_process (std::vector<block_pos> &vblkpos1,
                       std::vector<block_pos> &vblkpos2);

    void cut_range (range_pos rng_input);

    void merge_range_pos (range_pos rng_input);

    void extract_ranges (range_pos range_input);

    /// create a function_t with a call to merge_range_pos, and insert
    ///        in the stack of the backbone
    //
    /// @param rng_input : range of positions of blocks in the index to merge
    /// @param son_counter : atomic variable which is decremented when finish
    ///                      the function. This variable is used for to know
    ///                      when are finished all the function_t created
    ///                      inside an object
    /// @param error : global indicator of error.
    void function_merge_range_pos (const range_pos &rng_input,
                                   atomic_t &counter, bool &error)
        {
        util::atomic_add (counter, 1);
        function_t f1 = [this, rng_input, &counter, &error]( ) -> void {
            if (not error) {
                try
                    {
                    this->merge_range_pos (rng_input);
                    }
                catch (std::bad_alloc &ba)
                    {
                    error = true;
                    };
                }
            util::atomic_sub (counter, 1);
            };
        bk.works.emplace_back (f1);
        };

    /// create a function_t with a call to cut_range, and inser in
    ///        the stack of the backbone
    //
    /// @param rng_input : range of positions in the index to cut
    /// @param counter : atomic variable which is decremented when finish
    ///                  the function. This variable is used for to know
    ///                  when are finished all the function_t created
    ///                  inside an object
    /// @param error : global indicator of error.
    void function_cut_range (const range_pos &rng_input, atomic_t &counter,
                             bool &error)
        {
        util::atomic_add (counter, 1);
        function_t f1 = [this, rng_input, &counter, &error]( ) -> void {
            if (not error) {
                try
                    {
                    this->cut_range (rng_input);
                    }
                catch (std::bad_alloc &)
                    {
                    error = true;
                    };
                }
            util::atomic_sub (counter, 1);
            };
        bk.works.emplace_back (f1);
        };

    }; // end struct merge_blocks

//
// Non-inline merge_blocks methods
//

/// make the indirect merge of the two range_pos defined by their index
///        position [pos_index1, pos_index2 ) and [ pos_index2, pos_index3 )
/// @param bkb : backbone with all the data to sort , and the internal data
///              structures of the algorithm
/// @param pos_index1 : first position of the first range in the index
/// @param pos_index2 : last position of the first range and first position
///                     of the second range in the index
/// @param pos_index3 : last position of the second range in the index
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
merge_blocks<Block_size, Group_size, Iter_t, Compare>::merge_blocks(
        backbone_t &bkb, size_t pos_index1, size_t pos_index2, size_t pos_index3) : bk (bkb)
    {
    size_t nblock1 = pos_index2 - pos_index1;
    size_t nblock2 = pos_index3 - pos_index2;
    if (nblock1 == 0 or nblock2 == 0) return;

    // Merging of the two intervals
    std::vector<block_pos> vpos1, vpos2;
    vpos1.reserve (nblock1 + 1);
    vpos2.reserve (nblock2 + 1);

    for (size_t i = pos_index1; i < pos_index2; ++i) {
        vpos1.emplace_back (bk.index[i].pos(), true);
        };

    for (size_t i = pos_index2; i < pos_index3; ++i) {
        vpos2.emplace_back (bk.index[i].pos(), false);
        };

    //  tail process
    if (vpos2.back().pos() == (bk.nblock - 1) and
        bk.range_tail.first != bk.range_tail.last)
        {
        tail_process (vpos1, vpos2);
        nblock1 = vpos1.size();
        nblock2 = vpos2.size();
        };

    compare_block_pos_t cmp_blk (bk.global_range.first, bk.cmp);
    if (bk.error) return;
    util::full_merge (vpos1.begin(), vpos1.end(), vpos2.begin(),
                      vpos2.end(), bk.index.begin() + pos_index1, cmp_blk);
    if (bk.error) return;
    // Extracting the ranges for to merge the elements
    extract_ranges (range_pos (pos_index1, pos_index1 + nblock1 + nblock2));
    }

/// make the process when the second vector of block_pos to merge is
///        the last, and have an incomplete block ( tail)
/// @param vblkpos1 : first vector of block_pos elements to merge
/// @param vblkpos2 : second vector of block_pos elements to merge
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
void merge_blocks<Block_size, Group_size, Iter_t, Compare>::tail_process(
        std::vector<block_pos> &vblkpos1,
        std::vector<block_pos> &vblkpos2)
    {
    if (vblkpos1.empty() or vblkpos2.empty()) return;

    vblkpos2.pop_back();

    size_t posback1 = vblkpos1.back().pos();
    range_it range_back1 = bk.get_range (posback1);

    if (util::is_mergeable (range_back1, bk.range_tail, bk.cmp)) {
        util::in_place_merge_uncontiguous (range_back1, bk.range_tail,
                                           bk.get_range_buf(), bk.cmp);
        if (vblkpos1.size() > 1) {
            size_t pos_aux = vblkpos1[vblkpos1.size() - 2].pos();
            range_it range_aux = bk.get_range (pos_aux);

            if (util::is_mergeable (range_aux, range_back1, bk.cmp)) {
                vblkpos2.emplace_back (posback1, false);
                vblkpos1.pop_back();
                };
            };
        };
    }

/// when the rng_input is greather than Group_size, this function divide
///        it in several parts creating function_t elements, which are inserted
///        in the concurrent stack of the backbone
/// @param rng_input : range to divide
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
void merge_blocks<Block_size, Group_size, Iter_t, Compare>::cut_range (range_pos rng_input)
    {
    if (rng_input.size() < Group_size) {
        merge_range_pos (rng_input);
        return;
        };

    atomic_t counter (0);
    size_t npart = (rng_input.size() + Group_size - 1) / Group_size;
    size_t size_part = rng_input.size() / npart;

    size_t pos_ini = rng_input.first;
    size_t pos_last = rng_input.last;

    while (pos_ini < pos_last) {
        size_t pos = pos_ini + size_part;
        while (pos < pos_last and
               bk.index[pos - 1].side() == bk.index[pos].side())
            {
            ++pos;
            };
        if (pos < pos_last) {
            in_place_merge_uncontiguous (
                bk.get_range (bk.index[pos - 1].pos()),
                bk.get_range (bk.index[pos].pos()), bk.get_range_buf(),
                bk.cmp);
            }
        else
            pos = pos_last;
        if ((pos - pos_ini)> 1) {
            range_pos rng_aux (pos_ini, pos);
            function_merge_range_pos (rng_aux, counter, bk.error);
            };
        pos_ini = pos;
        };
    bk.exec (counter); // wait until finish all the ranges
    }

/// make the indirect merge of the blocks inside the rng_input
/// @param rng_input : range of positions of the blocks to merge
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
void merge_blocks<Block_size, Group_size, Iter_t, Compare>::merge_range_pos (range_pos rng_input)
    {
    if (rng_input.size() < 2) return;
    range_buf rbuf = bk.get_range_buf();

    range_it rng_prev = bk.get_range (bk.index[rng_input.first].pos());
    init_move (rbuf, rng_prev);
    range_it rng_posx (rng_prev);

    for (size_t posx = rng_input.first + 1; posx != rng_input.last; ++posx) {
        rng_posx = bk.get_range (bk.index[posx].pos());
        util::merge_flow (rng_prev, rbuf, rng_posx, bk.cmp);
        rng_prev = rng_posx;

        };
    init_move (rng_posx, rbuf);
    }

/// From a big range of positions of blocks in the index. Examine which
///        are mergeable, and generate a couple of ranges for to be merged.
///        With the ranges obtained generate function_t elements and are
///        inserted in the concurrent stack.
///        When the range obtained is smaller than Group_size, generate a
///        function_t calling to merge_range_pos, when is greater, generate a
///        function_t calling to cut_range
/// @param rpos range_input : range of the position in the index, where must
///                           extract the ranges to merge
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
void merge_blocks<Block_size, Group_size, Iter_t, Compare>::extract_ranges (range_pos range_input)
    {
    if (range_input.size() < 2) return;
    atomic_t counter (0);

    // The names with x are positions of the index
    size_t posx_ini = range_input.first;
    block_pos bp_posx_ini = bk.index[posx_ini];

    range_it rng_max = bk.get_range (bp_posx_ini.pos());
    bool side_max = bp_posx_ini.side();

    block_pos bp_posx;
    range_it rng_posx = rng_max;
    bool side_posx = side_max;

    for (size_t posx = posx_ini + 1; posx <= range_input.last; ++posx) {
        bool final = (posx == range_input.last);
        bool mergeable = false;

        if (not final) {
            bp_posx = bk.index[posx];
            rng_posx = bk.get_range (bp_posx.pos());
            side_posx = bp_posx.side();
            mergeable = (side_max != side_posx and
                         is_mergeable (rng_max, rng_posx, bk.cmp));
            };
        if (bk.error) return;
        if (final or not mergeable) {
            range_pos rp_final (posx_ini, posx);
            if (rp_final.size() > 1) {
                if (rp_final.size() > Group_size) {
                    function_cut_range (rp_final, counter, bk.error);
                    }
                else
                    {
                    function_merge_range_pos (rp_final, counter, bk.error);
                    };
                };
            posx_ini = posx;
            if (not final) {
                rng_max = rng_posx;
                side_max = side_posx;
                };
            }
        else
            {
            if (bk.cmp (*(rng_max.back()), *(rng_posx.back()))) {
                rng_max = rng_posx;
                side_max = side_posx;
                };
            };
        };
    bk.exec (counter);
    }

/// @struct move_blocks
/// This class move the blocks, transforming a logical sort by an index, in physical sort
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
struct move_blocks
    {
    typedef move_blocks<Block_size, Group_size, Iter_t, Compare> this_type;
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;
    typedef std::atomic<uint32_t> atomic_t;
    typedef util::range<size_t> range_pos;
    typedef util::range<Iter_t> range_it;
    typedef util::range<value_t *> range_buf;
    typedef std::function<void(void)> function_t;
    typedef backbone<Block_size, Iter_t, Compare> backbone_t;

    // Object with the elements to sort and all internal data structures of the algorithm
    backbone_t &bk;

    explicit move_blocks(backbone_t &bkb);

    void move_sequence(const std::vector<size_t> &init_sequence);

    void move_long_sequence(const std::vector<size_t> &init_sequence);

    /// Create a function_t with a call to move_sequence, and insert
    ///        in the stack of the backbone
    ///
    /// @param sequence :sequence of positions for to move the blocks
    /// @param counter : atomic variable which is decremented when finish
    ///                  the function. This variable is used for to know
    ///                  when are finished all the function_t created
    ///                  inside an object
    /// @param error : global indicator of error.
    void function_move_sequence(std::vector<size_t> &sequence,
                                atomic_t &counter, bool &error)
        {
        util::atomic_add (counter, 1);
        function_t f1 = [this, sequence, &counter, &error]( ) -> void {
            if (not error) {
                try
                    {
                    this->move_sequence (sequence);
                    }
                catch (std::bad_alloc &)
                    {
                    error = true;
                    };
                }
            util::atomic_sub (counter, 1);
            };
        bk.works.emplace_back (f1);
        };

    /// Create a function_t with a call to move_long_sequence, and
    ///        insert in the stack of the backbone
    //
    /// @param sequence :sequence of positions for to move the blocks
    /// @param counter : atomic variable which is decremented when finish
    ///                  the function. This variable is used for to know
    ///                  when are finished all the function_t created
    ///                  inside an object
    /// @param error : global indicator of error.
    void function_move_long_sequence (std::vector<size_t> &sequence,
                                      atomic_t &counter, bool &error)
        {
        util::atomic_add (counter, 1);
        function_t f1 = [this, sequence, &counter, &error]( ) -> void {
            if (not error) {
                try
                    {
                    this->move_long_sequence (sequence);
                    }
                catch (std::bad_alloc &)
                    {
                    error = true;
                    };
                }
            util::atomic_sub (counter, 1);
            };
        bk.works.emplace_back (f1);
        };

    }; // end of struct move_blocks

//
// Non-inline methods of struct move_blocks
//

/// Constructor of the class for to move the blocks to their true
///        position obtained from the index
/// @param bkb : backbone with the index and the blocks
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
move_blocks<Block_size, Group_size, Iter_t, Compare>::move_blocks (backbone_t &bkb): bk (bkb)
    {
    std::vector<std::vector<size_t>> vsequence;
    vsequence.reserve (bk.index.size() >> 1);
    std::vector<size_t> sequence;
    atomic_t counter (0);

    size_t pos_index_ini = 0, pos_index_src = 0, pos_index_dest = 0;
    while (pos_index_ini < bk.index.size()) {
        while (pos_index_ini < bk.index.size() and
               bk.index[pos_index_ini].pos() == pos_index_ini)
            {
            ++pos_index_ini;
            };

        if (pos_index_ini == bk.index.size()) break;

        sequence.clear();
        pos_index_src = pos_index_dest = pos_index_ini;
        sequence.push_back (pos_index_ini);

        while (bk.index[pos_index_dest].pos() != pos_index_ini) {
            pos_index_src = bk.index[pos_index_dest].pos();
            sequence.push_back (pos_index_src);

            bk.index[pos_index_dest].set_pos (pos_index_dest);
            pos_index_dest = pos_index_src;
            };

        bk.index[pos_index_dest].set_pos (pos_index_dest);
        vsequence.push_back (sequence);

        if (sequence.size() < Group_size) {
            function_move_sequence (vsequence.back(), counter, bk.error);
            }
        else
            {
            function_move_long_sequence (vsequence.back(), counter, bk.error);
            };
        };
    bk.exec (counter);
    }

/// Move the blocks, following the positions of the init_sequence
/// @param init_sequence : vector with the positions from and where move the
///                        blocks
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
void move_blocks<Block_size, Group_size, Iter_t, Compare>::move_sequence (const std::vector<size_t> &init_sequence)
    {
    range_buf rbuf = bk.get_range_buf();
    size_t pos_range2 = init_sequence[0];

    range_it range2 = bk.get_range (pos_range2);
    init_move (rbuf, range2);

    for (size_t i = 1; i < init_sequence.size(); ++i) {
        pos_range2 = init_sequence[i];
        range_it range1 (range2);
        range2 = bk.get_range (pos_range2);
        init_move (range1, range2);
        };
    init_move (range2, rbuf);
    }

/// Move the blocks, following the positions of the init_sequence.
///        if the sequence is greater than Group_size, it is divided in small
///        sequences, creating function_t elements, for to be inserted in the
///        concurrent stack
/// @param init_sequence : vector with the positions from and where move the
///                        blocks
template <uint32_t Block_size, uint32_t Group_size, class Iter_t, class Compare>
void move_blocks<Block_size, Group_size, Iter_t, Compare>::move_long_sequence (const std::vector<size_t> &init_sequence)
    {
    if (init_sequence.size() < Group_size)
        return move_sequence (init_sequence);

    size_t npart = (init_sequence.size() + Group_size - 1) / Group_size;
    size_t size_part = init_sequence.size() / npart;
    atomic_t son_counter (0);

    std::vector<size_t> sequence;
    sequence.reserve (size_part);

    std::vector<size_t> index_seq;
    index_seq.reserve (npart);

    auto it_pos = init_sequence.begin();
    for (size_t i = 0; i < (npart - 1); ++i, it_pos += size_part) {
        sequence.assign (it_pos, it_pos + size_part);
        index_seq.emplace_back (*(it_pos + size_part - 1));
        function_move_sequence (sequence, son_counter, bk.error);
        };

    sequence.assign (it_pos, init_sequence.end());
    index_seq.emplace_back (init_sequence.back());
    function_move_sequence (sequence, son_counter, bk.error);

    bk.exec (son_counter);
    if (bk.error) return;
    move_long_sequence (index_seq);
    }

using SGMInternal::detail::util::nbits64;

/// @struct parallel_sort
/// This class do a parallel sort, using the quicksort filtering,
///        splitting the data until the number of elements is smaller than a
///        predefined value (max_per_thread)
template <uint32_t Block_size, class Iter_t, class Compare>
struct parallel_sort
    {
    typedef typename std::iterator_traits<Iter_t>::value_type value_t;
    typedef std::atomic<uint32_t> atomic_t;
    typedef std::function<void(void)> function_t;
    typedef backbone<Block_size, Iter_t, Compare> backbone_t;

    // reference to a object with all the data to sort
    backbone_t &bk;

    // maximun number of element to sort woth 1 thread
    size_t max_per_thread;

    // atomic counter for to detect the end of the works created inside
    // the object
    atomic_t counter;

    parallel_sort (backbone_t &bkbn, Iter_t first, Iter_t last);

    void divide_sort (Iter_t first, Iter_t last, uint32_t level);

    /// Create a function_t with a call to divide_sort, and inser in
    ///        the stack of the backbone
    /// @param first : iterator to the first element of the range to divide
    /// @param last : iterator to the next element after the last element of
    ///               the range to divide
    /// @param level : level of depth in the division.When zero call to
    ///                introsort
    /// @param counter : atomic variable which is decremented when finish
    ///                  the function. This variable is used for to know
    ///                  when are finished all the function_t created
    ///                  inside an object
    /// @param error : global indicator of error.
    void function_divide_sort (Iter_t first, Iter_t last, uint32_t level,
                               atomic_t &counter, bool &error)
        {
        util::atomic_add (counter, 1);
        function_t f1 = [this, first, last, level, &counter, &error]( ) {
            if (not error) {
                try
                    {
                    this->divide_sort (first, last, level);
                    }
                catch (std::bad_alloc &)
                    {
                    error = true;
                    };
                };
            util::atomic_sub (counter, 1);
            };
        bk.works.emplace_back (f1);
        };

    }; // end struct parallel_sort

//
// Non-inline parallel_sort methods
//

/// Constructor
/// @param [in] bkbn : backbone struct with all the information to sort
/// @param [in] first : iterator to the first element to sort
/// @param [in] last : iterator to the next element after the last
template <uint32_t Block_size, class Iter_t, class Compare>
parallel_sort<Block_size, Iter_t, Compare>::parallel_sort (backbone_t &bkbn, Iter_t first, Iter_t last)
    : bk (bkbn), counter (0)
    {
    assert ((last - first) >= 0);
    size_t nelem = size_t (last - first);

    // check if sort
    bool sorted = true;
    for (Iter_t it1 = first, it2 = first + 1;
         it2 != last and (sorted = not bk.cmp (*it2, *it1)); it1 = it2++)
        ;
    if (sorted) return;

    // max_per_thread
    uint32_t nbits_size = (nbits64 (sizeof(value_t))) >> 1;
    if (nbits_size > 5) nbits_size = 5;
    max_per_thread = (size_t)(1 << (18 - nbits_size));

    uint32_t level = ((nbits64 (nelem / max_per_thread)) * 3) / 2;

    // check if only single thread
    if (nelem < (max_per_thread)) {
        intro_sort (first, last, bk.cmp);
        return;
        };
    if (not bk.error) divide_sort (first, last, level);

    // wait until all the parts are finished
    bk.exec (counter);
    }

/// Divide the data in two parts, to be sorted in a parallel mode.
/// @param first : iterator to the first element to sort
/// @param last : iterator to the next element after the last
/// @param level : level of depth before call to introsort
template <uint32_t Block_size, class Iter_t, class Compare>
void parallel_sort<Block_size, Iter_t, Compare>::divide_sort (Iter_t first, Iter_t last, uint32_t level)
    {
    // check if sort
    bool sorted = true;
    for (Iter_t it1 = first, it2 = first + 1;
         it2 != last and (sorted = not bk.cmp (*it2, *it1)); it1 = it2++)
        ;
    if (sorted) return;

    // check if finish the subdivision
    size_t nelem = last - first;
    if (level == 0 or nelem < (max_per_thread)) {
        return intro_sort (first, last, bk.cmp);
        };

    // pivoting
    pivot9 (first, last, bk.cmp);
    const value_t &val = const_cast<value_t &> (*first);
    Iter_t c_first = first + 1, c_last = last - 1;

    while (bk.cmp (*c_first, val)) ++c_first;
    while (bk.cmp (val, *c_last)) --c_last;

    while (not(c_first > c_last)) {
        std::swap (*(c_first++), *(c_last--));
        while (bk.cmp (*c_first, val)) ++c_first;
        while (bk.cmp (val, *c_last)) --c_last;
        };

    std::swap (*first, *c_last);

    // insert  the work of the second half in the stack of works
    function_divide_sort (c_first, last, level - 1, counter, bk.error);
    if (bk.error) return;

    // The first half is done by the same thread
    function_divide_sort (first, c_last, level - 1, counter, bk.error);
    }

///////////////////////////////////////////////////////////////////////////////
} //    End namespace bis
///////////////////////////////////////////////////////////////////////////////
} // end namespace detail
///////////////////////////////////////////////////////////////////////////////
} // end namespace SGMInternal

#endif //SGM_INTERNAL_SORTIMPLEMENTATION_H
