#ifndef SGM_INTERNAL_SORT_H
#define SGM_INTERNAL_SORT_H

///////////////////////////////////////////////////////////////////////////////
//
// PARALLEL THREADED SORT
//
///////////////////////////////////////////////////////////////////////////////

// This file contains code derived and modified with permission from the
// original sort_parallel library (https://github.com/fjtapia/sort_parallel).
//
// Copyright (c) 2016 Francisco Jose Tapia (fjtapia@gmail.com)
// Distributed under the Boost Software License, Version 1.0.
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include "parallel_sort_details.h"

namespace SGMInternal
{

using std::iterator_traits;
using detail::less_ptr_no_null;
using detail::util::compare_iter;
using detail::util::enable_if_not_integral;

///////////////////////////////////////////////////////////////////////////////
//
// UNSTABLE SORT, INDIRECT_SORT
//
///////////////////////////////////////////////////////////////////////////////

/// Unstable sort, based on the intro_sort algorithm
template<class Iter_t, typename Compare = compare_iter<Iter_t> >
void sort(Iter_t first, Iter_t last, Compare comp = Compare())
    {
    detail::intro_sort(first, last, comp);
    };

/// Indirect sort.
//  Sort a vector of iterators to the elements, and after, move the elements
//  in sort order, useful with big objects.
template<class Iter_t, typename Compare = compare_iter<Iter_t> >
void indirect_sort(Iter_t first, Iter_t last, Compare comp = Compare())
    {
    typedef less_ptr_no_null<Iter_t, Compare> compare_ptr;

    std::vector<Iter_t> v_iter;
    detail::create_index(first, last, v_iter);
    detail::intro_sort(v_iter.begin(), v_iter.end(), compare_ptr(comp));
    detail::sort_index(first, v_iter);
    };

///////////////////////////////////////////////////////////////////////////////
//
// UNSTABLE PARALLEL SORT
//
///////////////////////////////////////////////////////////////////////////////

///  A non stable parallel sort, default comparison.
template<class Iter_t>
void parallel_sort(Iter_t first, Iter_t last)
    {
    typedef compare_iter<Iter_t> Compare;
    detail::select_block_indirect(first, last, Compare());
    };

///  A non stable parallel sort, default comparison, specifying number of threads.
template<class Iter_t>
void parallel_sort(Iter_t first, Iter_t last, uint32_t nthread)
    {
    typedef compare_iter<Iter_t> Compare;
    detail::select_block_indirect(first, last, Compare(), nthread);
    };

/// A non stable parallel sort, given a comparison, specifying number of threads.
template<class Iter_t, class Compare>
void parallel_sort(Iter_t first, Iter_t last, Compare comp, uint32_t nthread)
    {
    detail::select_block_indirect(first, last, comp, nthread);
    };

/// A non stable parallel sort, given a comparison, default number of threads.
template<class Iter_t, class Compare,
    enable_if_not_integral<Compare> * = nullptr>
void parallel_sort(Iter_t first, Iter_t last, Compare comp)
    {
    detail::select_block_indirect(first, last, comp);
    };

///////////////////////////////////////////////////////////////////////////////
//
// STABLE SORT, INDIRECT STABLE SORT, SINGLE THREAD
//
///////////////////////////////////////////////////////////////////////////////

/// Stable single threaded sort.
template<class Iter_t, class Compare = compare_iter<Iter_t> >
void stable_sort(Iter_t first, Iter_t last, Compare comp = Compare())
    {
    detail::spin_sort<Iter_t, Compare>(first, last, comp);
    };

/// Stable single threaded indirect sort.
//  Sort a vector of iterators to the elements, and after, move the elements
//  in sort order, useful with big objects.
template<class Iter_t, class Compare = compare_iter<Iter_t> >
void indirect_stable_sort(Iter_t first, Iter_t last,
                          Compare comp = Compare())
    {
    typedef less_ptr_no_null<Iter_t, Compare> compare_ptr;
    typedef typename std::vector<Iter_t>::iterator iter_ptr;

    std::vector<Iter_t> v_iter;
    detail::create_index(first, last, v_iter);
    detail::spin_sort<iter_ptr, compare_ptr>
        (v_iter.begin(), v_iter.end(), compare_ptr(comp));
    detail::sort_index(first, v_iter);
    };

///////////////////////////////////////////////////////////////////////////////
//
// PARALLEL STABLE SORT
//
///////////////////////////////////////////////////////////////////////////////

/// Parallel stable sort, default comparison, default number of threads.
template<class Iter_t>
void parallel_stable_sort(Iter_t first, Iter_t last)
    {
    typedef compare_iter<Iter_t> Compare;
    detail::parallel_stable_sort<Iter_t, Compare>(first, last);
    };

/// Parallel stable sort, default comparison, specifying number of threads.
template<class Iter_t>
void parallel_stable_sort(Iter_t first, Iter_t last, uint32_t nthread)
    {
    typedef compare_iter<Iter_t> Compare;
    detail::parallel_stable_sort<Iter_t, Compare>(first, last, nthread);
    };

/// Parallel stable sort, given comparison, default number of threads.
template<class Iter_t, class Compare,
    enable_if_not_integral<Compare> * = nullptr>
void parallel_stable_sort(Iter_t first, Iter_t last, Compare comp)
    {
    detail::parallel_stable_sort<Iter_t, Compare>(first, last, comp);
    };

/// Parallel_stable_sort, given comparison, specifying number of threads.
template<class Iter_t, typename Compare>
void parallel_stable_sort(Iter_t first, Iter_t last, Compare comp,
                          uint32_t nthread)
    {
    detail::parallel_stable_sort<Iter_t, Compare>(first, last, comp,
                                                  nthread);
    };

///////////////////////////////////////////////////////////////////////////////
//
// PARALLEL STABLE SAMPLE SORT
//
///////////////////////////////////////////////////////////////////////////////

/// Parallel stable sort using sample algorithm, default comparison, using default number of threads.
template<class Iter_t>
void sample_sort(Iter_t first, Iter_t last)
    {
    typedef compare_iter<Iter_t> Compare;
    detail::sample_sort<Iter_t, Compare>(first, last);
    };

/// Parallel stable sort using sample algorithm, specifying number of threads.
template<class Iter_t>
void sample_sort(Iter_t first, Iter_t last, uint32_t nthread)
    {
    typedef compare_iter<Iter_t> Compare;
    detail::sample_sort<Iter_t, Compare>(first, last, nthread);
    };

/// Parallel stable sort using sample algorithm, given comparison, default number of threads.
template<class Iter_t, class Compare,
    enable_if_not_integral<Compare> * = nullptr>
void sample_sort(Iter_t first, Iter_t last, Compare comp)
    {
    detail::sample_sort<Iter_t, Compare>(first, last, comp);
    };

/// Parallel stable sort using sample algorithm, given comparison, specifying number of threads.
template<class Iter_t, class Compare>
void sample_sort(Iter_t first, Iter_t last, Compare comp, uint32_t nthread)
    {
    detail::sample_sort<Iter_t, Compare>(first, last, comp, nthread);
    };

};   // End namespace SGMInternal

#endif
